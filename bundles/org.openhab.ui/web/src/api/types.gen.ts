// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: `${string}://${string}/rest` | (string & {});
};

export type ConfigDescriptionParameter = {
    context?: string;
    defaultValue?: string;
    description?: string;
    label?: string;
    name: string;
    required?: boolean;
    type: 'TEXT' | 'INTEGER' | 'DECIMAL' | 'BOOLEAN';
    min?: number;
    max?: number;
    stepsize?: number;
    pattern?: string;
    readOnly?: boolean;
    multiple?: boolean;
    multipleLimit?: number;
    groupName?: string;
    advanced?: boolean;
    verify?: boolean;
    limitToOptions?: boolean;
    unit?: string;
    unitLabel?: string;
    options?: Array<ParameterOption>;
    filterCriteria?: Array<FilterCriteria>;
};

export type FilterCriteria = {
    value: string;
    name: string;
};

export type ModuleType = {
    uid: string;
    visibility: 'VISIBLE' | 'HIDDEN' | 'EXPERT';
    tags: Array<string>;
    label?: string;
    description?: string;
    configDescriptions: Array<ConfigDescriptionParameter>;
};

export type ParameterOption = {
    label: string;
    value: string;
};

export type Action = {
    id: string;
    label?: string;
    description?: string;
    configuration: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
    type: string;
    inputs: {
        [key: string]: string;
    };
};

export type Condition = {
    id: string;
    label?: string;
    description?: string;
    configuration: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
    type: string;
    inputs: {
        [key: string]: string;
    };
};

export type Rule = {
    triggers: Array<Trigger>;
    conditions: Array<Condition>;
    actions: Array<Action>;
    configuration: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
    configDescriptions: Array<ConfigDescriptionParameter>;
    templateUID?: string;
    templateState: string;
    uid: string;
    name?: string;
    tags: Array<string>;
    visibility: 'VISIBLE' | 'HIDDEN' | 'EXPERT';
    description?: string;
};

export type Trigger = {
    id: string;
    label?: string;
    description?: string;
    configuration: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
    type: string;
};

export type EnrichedRule = {
    triggers: Array<Trigger>;
    conditions: Array<Condition>;
    actions: Array<Action>;
    configuration: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
    configDescriptions: Array<ConfigDescriptionParameter>;
    templateUID?: string;
    templateState: string;
    uid: string;
    name?: string;
    tags: Array<string>;
    visibility: 'VISIBLE' | 'HIDDEN' | 'EXPERT';
    description?: string;
    status?: RuleStatusInfo;
    editable: boolean;
};

export type RuleStatusInfo = {
    status: 'UNINITIALIZED' | 'INITIALIZING' | 'IDLE' | 'RUNNING';
    statusDetail: 'NONE' | 'HANDLER_MISSING_ERROR' | 'HANDLER_INITIALIZING_ERROR' | 'CONFIGURATION_ERROR' | 'TEMPLATE_MISSING_ERROR' | 'TEMPLATE_PENDING' | 'INVALID_RULE' | 'DISABLED';
    description: string;
};

export type Module = {
    configuration: Configuration;
    typeUID: string;
    id: string;
    label: string;
    description: string;
};

export type Configuration = {
    properties: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
};

export type RuleExecution = {
    date: string;
    rule: Rule;
};

export type Template = {
    uid: string;
    tags: Array<string>;
    visibility: 'VISIBLE' | 'HIDDEN' | 'EXPERT';
    label: string;
    description: string;
};

export type Input = {
    name: string;
    type: string;
    label: string;
    description: string;
    required: boolean;
    tags: Array<string>;
    reference: string;
    defaultValue: string;
};

export type Output = {
    name: string;
    type: string;
    tags: Array<string>;
    label: string;
    description: string;
    reference: string;
    defaultValue: string;
};

export type ThingAction = {
    actionUid: string;
    label?: string;
    description?: string;
    visibility?: 'VISIBLE' | 'HIDDEN' | 'EXPERT';
    inputs: Array<Input>;
    inputConfigDescriptions?: Array<ConfigDescriptionParameter>;
    outputs?: Array<Output>;
};

export type AudioSink = {
    id: string;
    label?: string;
};

export type AudioSource = {
    id: string;
    label?: string;
};

export type UserApiToken = {
    name: string;
    createdTime: string;
    scope: string;
};

export type UserSession = {
    sessionId: string;
    createdTime: string;
    lastRefreshTime: string;
    clientId: string;
    scope: string;
};

export type TokenResponse = {
    access_token: string;
    token_type: string;
    expires_in: number;
    refresh_token: string;
    scope: string;
    user: User;
};

export type User = {
    name: string;
    roles: Array<string>;
};

export type Addon = {
    uid: string;
    id: string;
    label: string;
    version: string;
    maturity: string;
    compatible: boolean;
    contentType: string;
    link: string;
    author: string;
    verifiedAuthor: boolean;
    installed: boolean;
    type: string;
    description: string;
    detailedDescription: string;
    configDescriptionURI: string;
    keywords: string;
    countries: Array<string>;
    license: string;
    connection: string;
    backgroundColor: string;
    imageLink: string;
    properties: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
    loggerPackages: Array<string>;
};

export type AddonType = {
    id: string;
    label: string;
};

export type ChannelType = {
    parameters: Array<ConfigDescriptionParameter>;
    parameterGroups: Array<ConfigDescriptionParameterGroup>;
    description?: string;
    label: string;
    category?: string;
    itemType?: string;
    unitHint?: string;
    kind: 'STATE' | 'TRIGGER';
    stateDescription?: StateDescription;
    tags: Array<string>;
    UID: string;
    advanced: boolean;
    commandDescription?: CommandDescription;
};

export type CommandDescription = {
    commandOptions: Array<CommandOption>;
};

export type CommandOption = {
    command: string;
    label: string;
};

export type ConfigDescriptionParameterGroup = {
    name: string;
    context?: string;
    advanced: boolean;
    label?: string;
    description?: string;
};

export type StateDescription = {
    minimum: number;
    maximum: number;
    step: number;
    pattern: string;
    readOnly: boolean;
    options: Array<StateOption>;
};

export type StateOption = {
    value: string;
    label: string;
};

export type ConfigDescription = {
    uri?: string;
    parameters: Array<ConfigDescriptionParameter>;
    parameterGroups: Array<ConfigDescriptionParameterGroup>;
};

export type DiscoveryInfo = {
    inputSupported: boolean;
    inputLabel?: string;
    inputDescription?: string;
};

export type DiscoveryResult = {
    bridgeUID?: string;
    flag: 'NEW' | 'IGNORED';
    label: string;
    properties: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
    representationProperty?: string;
    thingUID: string;
    thingTypeUID?: string;
};

export type Channel = {
    uid: string;
    id: string;
    channelTypeUID?: string;
    itemType?: string;
    kind: string;
    label?: string;
    description?: string;
    defaultTags: Array<string>;
    properties: {
        [key: string]: string;
    };
    configuration: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
    autoUpdatePolicy?: string;
};

export type FileFormat = {
    items: Array<FileFormatItem>;
    things: Array<Thing>;
};

export type FileFormatChannelLink = {
    channelUID: string;
    configuration?: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
};

export type FileFormatItem = {
    type: string;
    name: string;
    label?: string;
    category?: string;
    tags?: Array<string>;
    groupNames?: Array<string>;
    groupType?: string;
    function?: GroupFunction;
    format?: string;
    metadata?: {
        [key: string]: Metadata;
    };
    channelLinks?: Array<FileFormatChannelLink>;
};

export type GroupFunction = {
    name: string;
    params?: Array<string>;
};

export type Metadata = {
    value: string;
    config?: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
    editable: boolean;
};

export type Thing = {
    label?: string;
    bridgeUID?: string;
    configuration: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
    properties: {
        [key: string]: string;
    };
    UID: string;
    thingTypeUID: string;
    location?: string;
    semanticEquipmentTag?: string;
    channels: Array<Channel>;
};

export type ExtendedFileFormat = {
    items: Array<FileFormatItem>;
    things: Array<Thing>;
    warnings: Array<string>;
};

export type EnrichedItem = {
    type: string;
    name: string;
    label?: string;
    category?: string;
    tags?: Array<string>;
    groupNames?: Array<string>;
    link?: string;
    state: string;
    transformedState?: string;
    stateDescription?: StateDescription;
    commandDescription?: CommandDescription;
    lastState?: string;
    lastStateUpdate?: number;
    lastStateChange?: number;
    unitSymbol?: string;
    metadata?: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
    parents?: Array<EnrichedItem>;
    editable: boolean;
};

export type GroupItem = {
    type: string;
    name: string;
    label?: string;
    category?: string;
    tags?: Array<string>;
    groupNames?: Array<string>;
    groupType?: string;
    function?: GroupFunction;
};

export type EnrichedGroupItem = {
    type: string;
    name: string;
    label?: string;
    category?: string;
    tags?: Array<string>;
    groupNames?: Array<string>;
    link?: string;
    state: string;
    transformedState?: string;
    stateDescription?: StateDescription;
    commandDescription?: CommandDescription;
    lastState?: string;
    lastStateUpdate?: number;
    lastStateChange?: number;
    unitSymbol?: string;
    metadata?: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
    parents?: Array<EnrichedItem>;
    editable: boolean;
    members?: Array<EnrichedItem>;
    groupType?: string;
    function?: GroupFunction;
};

export type ItemSemanticsProblem = {
    item: string;
    semanticType: string;
    reason: string;
    explanation: string;
    editable: boolean;
};

export type ValueContainer = {
    value: string;
    source: string;
};

export type EnrichedItemChannelLink = {
    itemName: string;
    channelUID: string;
    configuration: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
    editable: boolean;
};

export type BrokenItemChannelLink = {
    itemChannelLink: EnrichedItemChannelLink;
    problem: 'THING_CHANNEL_MISSING' | 'ITEM_MISSING' | 'ITEM_AND_THING_CHANNEL_MISSING';
};

export type ItemChannelLink = {
    itemName: string;
    channelUID: string;
    configuration: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
};

export type PersistenceServiceProblem = {
    reason: string;
    serviceId: string;
    items: Array<string>;
    editable: boolean;
};

export type HistoryDataBean = {
    time: number;
    state: string;
};

export type ItemHistory = {
    name: string;
    datapoints: string;
    data: Array<HistoryDataBean>;
};

export type PersistenceCronStrategy = {
    name: string;
    cronExpression: string;
};

export type PersistenceFilter = {
    name: string;
    value?: number;
    relative?: boolean;
    unit?: string;
    lower?: number;
    upper?: number;
    values?: Array<string>;
    inverted?: boolean;
};

export type PersistenceItemConfiguration = {
    items: Array<string>;
    strategies: Array<string>;
    filters: Array<string>;
};

export type PersistenceServiceConfiguration = {
    serviceId: string;
    configs: Array<PersistenceItemConfiguration>;
    aliases: {
        [key: string]: string;
    };
    defaults: Array<string>;
    cronStrategies: Array<PersistenceCronStrategy>;
    thresholdFilters: Array<PersistenceFilter>;
    timeFilters: Array<PersistenceFilter>;
    equalsFilters: Array<PersistenceFilter>;
    includeFilters: Array<PersistenceFilter>;
    editable: boolean;
};

export type PersistenceItemInfo = {
    latest: string;
    earliest: string;
    name: string;
    count: number;
};

export type PersistenceStrategy = {
    type: string;
    configuration: string;
};

export type PersistenceService = {
    id: string;
    label: string;
    type: string;
};

export type ProfileType = {
    uid: string;
    label: string;
    kind: string;
    supportedItemTypes: Array<string>;
};

export type ConfigurableService = {
    id: string;
    label: string;
    category: string;
    configDescriptionURI?: string;
    multiple: boolean;
};

export type EnrichedSemanticTag = {
    uid: string;
    name: string;
    label: string;
    description: string;
    synonyms: Array<string>;
    editable: boolean;
};

export type EnrichedChannel = {
    uid: string;
    id: string;
    channelTypeUID?: string;
    itemType?: string;
    kind: string;
    label?: string;
    description?: string;
    defaultTags: Array<string>;
    properties: {
        [key: string]: string;
    };
    configuration: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
    autoUpdatePolicy?: string;
    linkedItems: Array<string>;
};

export type EnrichedThing = {
    label?: string;
    bridgeUID?: string;
    configuration: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
    properties: {
        [key: string]: string;
    };
    UID: string;
    thingTypeUID: string;
    location?: string;
    semanticEquipmentTag?: string;
    channels: Array<EnrichedChannel>;
    statusInfo: ThingStatusInfo;
    firmwareStatus?: FirmwareStatus;
    editable: boolean;
};

export type FirmwareStatus = {
    status: string;
    updatableVersion: string;
};

export type ThingStatusInfo = {
    status: 'UNINITIALIZED' | 'INITIALIZING' | 'UNKNOWN' | 'ONLINE' | 'OFFLINE' | 'REMOVING' | 'REMOVED';
    statusDetail: 'NONE' | 'NOT_YET_READY' | 'HANDLER_MISSING_ERROR' | 'HANDLER_REGISTERING_ERROR' | 'HANDLER_INITIALIZING_ERROR' | 'HANDLER_CONFIGURATION_PENDING' | 'CONFIGURATION_PENDING' | 'COMMUNICATION_ERROR' | 'CONFIGURATION_ERROR' | 'BRIDGE_OFFLINE' | 'FIRMWARE_UPDATING' | 'DUTY_CYCLE' | 'BRIDGE_UNINITIALIZED' | 'GONE' | 'DISABLED';
    description?: string;
};

export type ConfigStatusMessage = {
    parameterName: string;
    type: 'INFORMATION' | 'WARNING' | 'ERROR' | 'PENDING';
    message: string;
    statusCode: number;
};

export type Firmware = {
    thingTypeUID: string;
    vendor?: string;
    model?: string;
    modelRestricted: boolean;
    description?: string;
    version: string;
    changelog?: string;
    prerequisiteVersion?: string;
};

export type StrippedThingType = {
    UID: string;
    label: string;
    description?: string;
    category?: string;
    listed: boolean;
    supportedBridgeTypeUIDs: Array<string>;
    bridge: boolean;
    semanticEquipmentTag?: string;
};

export type ChannelDefinition = {
    description?: string;
    id: string;
    label: string;
    tags: Array<string>;
    properties: {
        [key: string]: string;
    };
    category?: string;
    stateDescription?: StateDescription;
    advanced: boolean;
    typeUID: string;
};

export type ChannelGroupDefinition = {
    id: string;
    description?: string;
    label?: string;
    channels: Array<ChannelDefinition>;
};

export type ThingType = {
    UID: string;
    label: string;
    description?: string;
    category?: string;
    listed: boolean;
    supportedBridgeTypeUIDs: Array<string>;
    bridge: boolean;
    semanticEquipmentTag?: string;
    channels?: Array<ChannelDefinition>;
    channelGroups?: Array<ChannelGroupDefinition>;
    configParameters?: Array<ConfigDescriptionParameter>;
    parameterGroups?: Array<ConfigDescriptionParameterGroup>;
    properties?: {
        [key: string]: string;
    };
    extensibleChannelTypeIds?: Array<string>;
};

export type Links = {
    type: string;
    url: string;
};

export type RootBean = {
    version: string;
    locale: string;
    measurementSystem: 'SI' | 'US';
    timezone: string;
    runtimeInfo: RuntimeInfo;
    links: Array<Links>;
};

export type RuntimeInfo = {
    version: string;
    buildString: string;
};

export type SystemInfo = {
    configFolder: string;
    userdataFolder: string;
    logFolder: string;
    javaVersion: string;
    javaVendor: string;
    javaVendorVersion: string;
    osName: string;
    osVersion: string;
    osArchitecture: string;
    availableProcessors: number;
    freeMemory: number;
    totalMemory: number;
    uptime: number;
    startLevel: number;
};

export type SystemInfoBean = {
    systemInfo: SystemInfo;
};

export type DimensionInfo = {
    dimension: string;
    systemUnit: string;
};

export type UoMInfo = {
    dimensions: Array<DimensionInfo>;
};

export type UoMInfoBean = {
    uomInfo: UoMInfo;
};

export type Mapping = {
    row: number;
    column: number;
    command: string;
    releaseCommand: string;
    label: string;
    icon: string;
};

export type Page = {
    id: string;
    title: string;
    icon: string;
    link: string;
    parent: Page;
    leaf: boolean;
    timeout: boolean;
    widgets: Array<Widget>;
};

export type Widget = {
    widgetId: string;
    type: string;
    name: string;
    visibility: boolean;
    label: string;
    labelSource: string;
    icon: string;
    staticIcon: boolean;
    labelcolor: string;
    valuecolor: string;
    iconcolor: string;
    pattern: string;
    unit: string;
    mappings: Array<Mapping>;
    switchSupport: boolean;
    releaseOnly: boolean;
    refresh: number;
    height: number;
    minValue: number;
    maxValue: number;
    step: number;
    inputHint: string;
    url: string;
    encoding: string;
    service: string;
    period: string;
    yAxisDecimalPattern: string;
    interpolation: string;
    legend: boolean;
    forceAsItem: boolean;
    row: number;
    column: number;
    command: string;
    releaseCommand: string;
    stateless: boolean;
    state: string;
    item: EnrichedItem;
    linkedPage: Page;
};

export type Sitemap = {
    name: string;
    icon: string;
    label: string;
    link: string;
    homepage: Page;
};

export type Transformation = {
    uid: string;
    label: string;
    type: string;
    configuration: {
        [key: string]: string;
    };
    editable: boolean;
};

export type RootUiComponent = {
    component: string;
    config: {
        [key: string]: unknown;
    };
    slots: {
        [key: string]: Array<UiComponent>;
    };
    uid: string;
    tags: Array<string>;
    props: ConfigDescription;
    timestamp: string;
};

export type UiComponent = {
    component: string;
    config: {
        [key: string]: unknown;
    };
};

export type Tile = {
    name: string;
    url: string;
    overlay?: string;
    imageUrl: string;
};

export type Voice = {
    id: string;
    label: string;
    locale: string;
};

export type HumanLanguageInterpreter = {
    id: string;
    label: string;
    locales?: Array<string>;
};

export type LoggerInfo = {
    loggerName: string;
    level: string;
};

export type LoggerBean = {
    loggers: Array<LoggerInfo>;
};

export type IconSet = {
    id: string;
    label: string;
    description: string;
    formats: Array<'PNG' | 'SVG'>;
};

export type GetModuleTypesData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path?: never;
    query?: {
        /**
         * tags for filtering
         */
        tags?: string;
        /**
         * filtering by action, condition or trigger
         */
        type?: string;
        /**
         * returns an object of arrays by type instead of a mixed array
         */
        asMap?: boolean;
    };
    url: '/module-types';
};

export type GetModuleTypesResponses = {
    /**
     * OK
     */
    200: Array<ModuleType>;
};

export type GetModuleTypesResponse = GetModuleTypesResponses[keyof GetModuleTypesResponses];

export type GetModuleTypeByIdData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * moduleTypeUID
         */
        moduleTypeUID: string;
    };
    query?: never;
    url: '/module-types/{moduleTypeUID}';
};

export type GetModuleTypeByIdErrors = {
    /**
     * Module Type corresponding to the given UID does not found.
     */
    404: unknown;
};

export type GetModuleTypeByIdResponses = {
    /**
     * OK
     */
    200: ModuleType;
};

export type GetModuleTypeByIdResponse = GetModuleTypeByIdResponses[keyof GetModuleTypeByIdResponses];

export type GetRulesData = {
    body?: never;
    path?: never;
    query?: {
        prefix?: string;
        tags?: Array<string>;
        /**
         * summary fields only
         */
        summary?: boolean;
        /**
         * provides a cacheable list of values not expected to change regularly and honors the If-Modified-Since header, all other parameters are ignored
         */
        staticDataOnly?: boolean;
    };
    url: '/rules';
};

export type GetRulesResponses = {
    /**
     * OK
     */
    200: Array<EnrichedRule>;
};

export type GetRulesResponse = GetRulesResponses[keyof GetRulesResponses];

export type CreateRuleData = {
    /**
     * rule data
     */
    body: Rule;
    path?: never;
    query?: never;
    url: '/rules';
};

export type CreateRuleErrors = {
    /**
     * Creation of the rule is refused. Missing required parameter.
     */
    400: unknown;
    /**
     * Creation of the rule is refused. Rule with the same UID already exists.
     */
    409: unknown;
};

export type CreateRuleResponses = {
    /**
     * Created
     */
    201: unknown;
};

export type EnableRuleData = {
    /**
     * enable
     */
    body: string;
    path: {
        /**
         * ruleUID
         */
        ruleUID: string;
    };
    query?: never;
    url: '/rules/{ruleUID}/enable';
};

export type EnableRuleErrors = {
    /**
     * Rule corresponding to the given UID was not found.
     */
    404: unknown;
};

export type EnableRuleResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetRuleActionsData = {
    body?: never;
    path: {
        /**
         * ruleUID
         */
        ruleUID: string;
    };
    query?: never;
    url: '/rules/{ruleUID}/actions';
};

export type GetRuleActionsErrors = {
    /**
     * Rule corresponding to the given UID does not found.
     */
    404: unknown;
};

export type GetRuleActionsResponses = {
    /**
     * OK
     */
    200: Array<Action>;
};

export type GetRuleActionsResponse = GetRuleActionsResponses[keyof GetRuleActionsResponses];

export type DeleteRuleData = {
    body?: never;
    path: {
        /**
         * ruleUID
         */
        ruleUID: string;
    };
    query?: never;
    url: '/rules/{ruleUID}';
};

export type DeleteRuleErrors = {
    /**
     * Rule corresponding to the given UID does not found.
     */
    404: unknown;
};

export type DeleteRuleResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetRuleByIdData = {
    body?: never;
    path: {
        /**
         * ruleUID
         */
        ruleUID: string;
    };
    query?: never;
    url: '/rules/{ruleUID}';
};

export type GetRuleByIdErrors = {
    /**
     * Rule not found
     */
    404: unknown;
};

export type GetRuleByIdResponses = {
    /**
     * OK
     */
    200: EnrichedRule;
};

export type GetRuleByIdResponse = GetRuleByIdResponses[keyof GetRuleByIdResponses];

export type UpdateRuleData = {
    /**
     * rule data
     */
    body: Rule;
    path: {
        /**
         * ruleUID
         */
        ruleUID: string;
    };
    query?: never;
    url: '/rules/{ruleUID}';
};

export type UpdateRuleErrors = {
    /**
     * Rule corresponding to the given UID does not found.
     */
    404: unknown;
};

export type UpdateRuleResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetRuleConditionsData = {
    body?: never;
    path: {
        /**
         * ruleUID
         */
        ruleUID: string;
    };
    query?: never;
    url: '/rules/{ruleUID}/conditions';
};

export type GetRuleConditionsErrors = {
    /**
     * Rule corresponding to the given UID does not found.
     */
    404: unknown;
};

export type GetRuleConditionsResponses = {
    /**
     * OK
     */
    200: Array<Condition>;
};

export type GetRuleConditionsResponse = GetRuleConditionsResponses[keyof GetRuleConditionsResponses];

export type GetRuleConfigurationData = {
    body?: never;
    path: {
        /**
         * ruleUID
         */
        ruleUID: string;
    };
    query?: never;
    url: '/rules/{ruleUID}/config';
};

export type GetRuleConfigurationErrors = {
    /**
     * Rule corresponding to the given UID does not found.
     */
    404: unknown;
};

export type GetRuleConfigurationResponses = {
    /**
     * OK
     */
    200: string;
};

export type GetRuleConfigurationResponse = GetRuleConfigurationResponses[keyof GetRuleConfigurationResponses];

export type UpdateRuleConfigurationData = {
    /**
     * config
     */
    body?: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
    path: {
        /**
         * ruleUID
         */
        ruleUID: string;
    };
    query?: never;
    url: '/rules/{ruleUID}/config';
};

export type UpdateRuleConfigurationErrors = {
    /**
     * Rule corresponding to the given UID does not found.
     */
    404: unknown;
};

export type UpdateRuleConfigurationResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetRuleModuleByIdData = {
    body?: never;
    path: {
        /**
         * ruleUID
         */
        ruleUID: string;
        /**
         * moduleCategory
         */
        moduleCategory: string;
        /**
         * id
         */
        id: string;
    };
    query?: never;
    url: '/rules/{ruleUID}/{moduleCategory}/{id}';
};

export type GetRuleModuleByIdErrors = {
    /**
     * Rule corresponding to the given UID does not found or does not have a module with such Category and ID.
     */
    404: unknown;
};

export type GetRuleModuleByIdResponses = {
    /**
     * OK
     */
    200: Module;
};

export type GetRuleModuleByIdResponse = GetRuleModuleByIdResponses[keyof GetRuleModuleByIdResponses];

export type GetRuleModuleConfigData = {
    body?: never;
    path: {
        /**
         * ruleUID
         */
        ruleUID: string;
        /**
         * moduleCategory
         */
        moduleCategory: string;
        /**
         * id
         */
        id: string;
    };
    query?: never;
    url: '/rules/{ruleUID}/{moduleCategory}/{id}/config';
};

export type GetRuleModuleConfigErrors = {
    /**
     * Rule corresponding to the given UID does not found or does not have a module with such Category and ID.
     */
    404: unknown;
};

export type GetRuleModuleConfigResponses = {
    /**
     * OK
     */
    200: string;
};

export type GetRuleModuleConfigResponse = GetRuleModuleConfigResponses[keyof GetRuleModuleConfigResponses];

export type GetRuleModuleConfigParameterData = {
    body?: never;
    path: {
        /**
         * ruleUID
         */
        ruleUID: string;
        /**
         * moduleCategory
         */
        moduleCategory: string;
        /**
         * id
         */
        id: string;
        /**
         * param
         */
        param: string;
    };
    query?: never;
    url: '/rules/{ruleUID}/{moduleCategory}/{id}/config/{param}';
};

export type GetRuleModuleConfigParameterErrors = {
    /**
     * Rule corresponding to the given UID does not found or does not have a module with such Category and ID.
     */
    404: unknown;
};

export type GetRuleModuleConfigParameterResponses = {
    /**
     * OK
     */
    200: string;
};

export type GetRuleModuleConfigParameterResponse = GetRuleModuleConfigParameterResponses[keyof GetRuleModuleConfigParameterResponses];

export type SetRuleModuleConfigParameterData = {
    /**
     * value
     */
    body: string;
    path: {
        /**
         * ruleUID
         */
        ruleUID: string;
        /**
         * moduleCategory
         */
        moduleCategory: string;
        /**
         * id
         */
        id: string;
        /**
         * param
         */
        param: string;
    };
    query?: never;
    url: '/rules/{ruleUID}/{moduleCategory}/{id}/config/{param}';
};

export type SetRuleModuleConfigParameterErrors = {
    /**
     * Rule corresponding to the given UID does not found or does not have a module with such Category and ID.
     */
    404: unknown;
};

export type SetRuleModuleConfigParameterResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetRuleTriggersData = {
    body?: never;
    path: {
        /**
         * ruleUID
         */
        ruleUID: string;
    };
    query?: never;
    url: '/rules/{ruleUID}/triggers';
};

export type GetRuleTriggersErrors = {
    /**
     * Rule corresponding to the given UID does not found.
     */
    404: unknown;
};

export type GetRuleTriggersResponses = {
    /**
     * OK
     */
    200: Array<Trigger>;
};

export type GetRuleTriggersResponse = GetRuleTriggersResponses[keyof GetRuleTriggersResponses];

export type RegenerateRuleData = {
    body?: never;
    path: {
        /**
         * ruleUID
         */
        ruleUID: string;
    };
    query?: never;
    url: '/rules/{ruleUID}/regenerate';
};

export type RegenerateRuleErrors = {
    /**
     * A template-based rule with the given UID was not found.
     */
    404: unknown;
};

export type RegenerateRuleResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type RunRuleNow1Data = {
    /**
     * the context for running this rule
     */
    body?: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
    path: {
        /**
         * ruleUID
         */
        ruleUID: string;
    };
    query?: never;
    url: '/rules/{ruleUID}/runnow';
};

export type RunRuleNow1Errors = {
    /**
     * Rule corresponding to the given UID was not found.
     */
    404: unknown;
};

export type RunRuleNow1Responses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetScheduleRuleSimulationsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Start time of the simulated rule executions. Will default to the current time. [yyyy-MM-dd'T'HH:mm:ss.SSSZ]
         */
        from?: string;
        /**
         * End time of the simulated rule executions. Will default to 30 days after the start time. Must be less than 180 days after the given start time. [yyyy-MM-dd'T'HH:mm:ss.SSSZ]
         */
        until?: string;
    };
    url: '/rules/schedule/simulations';
};

export type GetScheduleRuleSimulationsErrors = {
    /**
     * The max. simulation duration of 180 days is exceeded.
     */
    400: unknown;
};

export type GetScheduleRuleSimulationsResponses = {
    /**
     * OK
     */
    200: Array<RuleExecution>;
};

export type GetScheduleRuleSimulationsResponse = GetScheduleRuleSimulationsResponses[keyof GetScheduleRuleSimulationsResponses];

export type GetTemplatesData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path?: never;
    query?: never;
    url: '/templates';
};

export type GetTemplatesResponses = {
    /**
     * OK
     */
    200: Array<Template>;
};

export type GetTemplatesResponse = GetTemplatesResponses[keyof GetTemplatesResponses];

export type GetTemplateByIdData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * templateUID
         */
        templateUID: string;
    };
    query?: never;
    url: '/templates/{templateUID}';
};

export type GetTemplateByIdErrors = {
    /**
     * Template corresponding to the given UID does not found.
     */
    404: unknown;
};

export type GetTemplateByIdResponses = {
    /**
     * OK
     */
    200: Template;
};

export type GetTemplateByIdResponse = GetTemplateByIdResponses[keyof GetTemplateByIdResponses];

export type ExecuteThingActionData = {
    /**
     * action inputs as map (parameter name as key / argument as value)
     */
    body?: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * thingUID
         */
        thingUID: string;
        /**
         * action type UID (including scope, separated by '.')
         */
        actionUid: string;
    };
    query?: never;
    url: '/actions/{thingUID}/{actionUid}';
};

export type ExecuteThingActionErrors = {
    /**
     * Action not found
     */
    404: unknown;
    /**
     * Creation of action handler or execution failed
     */
    500: unknown;
};

export type ExecuteThingActionResponses = {
    /**
     * OK
     */
    200: string;
};

export type ExecuteThingActionResponse = ExecuteThingActionResponses[keyof ExecuteThingActionResponses];

export type GetAvailableActionsForThingData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * thingUID
         */
        thingUID: string;
    };
    query?: never;
    url: '/actions/{thingUID}';
};

export type GetAvailableActionsForThingErrors = {
    /**
     * No actions found.
     */
    404: unknown;
};

export type GetAvailableActionsForThingResponses = {
    /**
     * OK
     */
    200: Array<ThingAction>;
};

export type GetAvailableActionsForThingResponse = GetAvailableActionsForThingResponses[keyof GetAvailableActionsForThingResponses];

export type GetUuidData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/uuid';
};

export type GetUuidResponses = {
    /**
     * OK
     */
    200: string;
};

export type GetUuidResponse = GetUuidResponses[keyof GetUuidResponses];

export type GetAudioDefaultSinkData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path?: never;
    query?: never;
    url: '/audio/defaultsink';
};

export type GetAudioDefaultSinkErrors = {
    /**
     * Sink not found
     */
    404: unknown;
};

export type GetAudioDefaultSinkResponses = {
    /**
     * OK
     */
    200: AudioSink;
};

export type GetAudioDefaultSinkResponse = GetAudioDefaultSinkResponses[keyof GetAudioDefaultSinkResponses];

export type GetAudioDefaultSourceData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path?: never;
    query?: never;
    url: '/audio/defaultsource';
};

export type GetAudioDefaultSourceErrors = {
    /**
     * Source not found
     */
    404: unknown;
};

export type GetAudioDefaultSourceResponses = {
    /**
     * OK
     */
    200: AudioSource;
};

export type GetAudioDefaultSourceResponse = GetAudioDefaultSourceResponses[keyof GetAudioDefaultSourceResponses];

export type GetAudioSinksData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path?: never;
    query?: never;
    url: '/audio/sinks';
};

export type GetAudioSinksResponses = {
    /**
     * OK
     */
    200: Array<AudioSink>;
};

export type GetAudioSinksResponse = GetAudioSinksResponses[keyof GetAudioSinksResponses];

export type GetAudioSourcesData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path?: never;
    query?: never;
    url: '/audio/sources';
};

export type GetAudioSourcesResponses = {
    /**
     * OK
     */
    200: Array<AudioSource>;
};

export type GetAudioSourcesResponse = GetAudioSourcesResponses[keyof GetAudioSourcesResponses];

export type DeleteSessionData = {
    body?: {
        refresh_token: string;
        id: string;
    };
    path?: never;
    query?: never;
    url: '/auth/logout';
};

export type DeleteSessionErrors = {
    /**
     * User is not authenticated
     */
    401: unknown;
    /**
     * User or refresh token not found
     */
    404: unknown;
};

export type DeleteSessionResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetApiTokensData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/auth/apitokens';
};

export type GetApiTokensErrors = {
    /**
     * User is not authenticated
     */
    401: unknown;
    /**
     * User not found
     */
    404: unknown;
};

export type GetApiTokensResponses = {
    /**
     * OK
     */
    200: Array<UserApiToken>;
};

export type GetApiTokensResponse = GetApiTokensResponses[keyof GetApiTokensResponses];

export type GetSessionsForCurrentUserData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/auth/sessions';
};

export type GetSessionsForCurrentUserErrors = {
    /**
     * User is not authenticated
     */
    401: unknown;
    /**
     * User not found
     */
    404: unknown;
};

export type GetSessionsForCurrentUserResponses = {
    /**
     * OK
     */
    200: Array<UserSession>;
};

export type GetSessionsForCurrentUserResponse = GetSessionsForCurrentUserResponses[keyof GetSessionsForCurrentUserResponses];

export type GetOAuthTokenData = {
    body?: {
        grant_type: string;
        code: string;
        redirect_uri: string;
        client_id: string;
        refresh_token: string;
        code_verifier: string;
    };
    path?: never;
    query?: {
        useCookie?: boolean;
    };
    url: '/auth/token';
};

export type GetOAuthTokenErrors = {
    /**
     * Invalid request parameters
     */
    400: unknown;
};

export type GetOAuthTokenResponses = {
    /**
     * OK
     */
    200: TokenResponse;
};

export type GetOAuthTokenResponse = GetOAuthTokenResponses[keyof GetOAuthTokenResponses];

export type RemoveApiTokenData = {
    body?: never;
    path: {
        name: string;
    };
    query?: never;
    url: '/auth/apitokens/{name}';
};

export type RemoveApiTokenErrors = {
    /**
     * User is not authenticated
     */
    401: unknown;
    /**
     * User or API token not found
     */
    404: unknown;
};

export type RemoveApiTokenResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetAddonsData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path?: never;
    query?: {
        /**
         * service ID
         */
        serviceId?: string;
    };
    url: '/addons';
};

export type GetAddonsErrors = {
    /**
     * Service not found
     */
    404: unknown;
};

export type GetAddonsResponses = {
    /**
     * OK
     */
    200: Array<Addon>;
};

export type GetAddonsResponse = GetAddonsResponses[keyof GetAddonsResponses];

export type GetAddonByIdData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * addon ID
         */
        addonId: string;
    };
    query?: {
        /**
         * service ID
         */
        serviceId?: string;
    };
    url: '/addons/{addonId}';
};

export type GetAddonByIdErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type GetAddonByIdResponses = {
    /**
     * OK
     */
    200: Addon;
};

export type GetAddonByIdResponse = GetAddonByIdResponses[keyof GetAddonByIdResponses];

export type GetAddonConfigurationData = {
    body?: never;
    path: {
        /**
         * addon ID
         */
        addonId: string;
    };
    query?: {
        /**
         * service ID
         */
        serviceId?: string;
    };
    url: '/addons/{addonId}/config';
};

export type GetAddonConfigurationErrors = {
    /**
     * Add-on does not exist
     */
    404: unknown;
    /**
     * Configuration can not be read due to internal error
     */
    500: unknown;
};

export type GetAddonConfigurationResponses = {
    /**
     * OK
     */
    200: string;
};

export type GetAddonConfigurationResponse = GetAddonConfigurationResponses[keyof GetAddonConfigurationResponses];

export type UpdateAddonConfigurationData = {
    body?: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
    path: {
        /**
         * Add-on id
         */
        addonId: string;
    };
    query?: {
        /**
         * service ID
         */
        serviceId?: string;
    };
    url: '/addons/{addonId}/config';
};

export type UpdateAddonConfigurationErrors = {
    /**
     * Add-on does not exist
     */
    404: unknown;
    /**
     * Configuration can not be updated due to internal error
     */
    500: unknown;
};

export type UpdateAddonConfigurationResponses = {
    /**
     * OK
     */
    200: string;
    /**
     * No old configuration
     */
    204: void;
};

export type UpdateAddonConfigurationResponse = UpdateAddonConfigurationResponses[keyof UpdateAddonConfigurationResponses];

export type GetAddonTypesData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path?: never;
    query?: never;
    url: '/addons/services';
};

export type GetAddonTypesResponses = {
    /**
     * OK
     */
    200: Array<AddonType>;
};

export type GetAddonTypesResponse = GetAddonTypesResponses[keyof GetAddonTypesResponses];

export type GetSuggestedAddonsData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path?: never;
    query?: never;
    url: '/addons/suggestions';
};

export type GetSuggestedAddonsResponses = {
    /**
     * OK
     */
    200: Array<Addon>;
};

export type GetSuggestedAddonsResponse = GetSuggestedAddonsResponses[keyof GetSuggestedAddonsResponses];

export type GetAddonServicesData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path?: never;
    query?: {
        /**
         * service ID
         */
        serviceId?: string;
    };
    url: '/addons/types';
};

export type GetAddonServicesErrors = {
    /**
     * Service not found
     */
    404: unknown;
};

export type GetAddonServicesResponses = {
    /**
     * OK
     */
    200: Array<AddonType>;
};

export type GetAddonServicesResponse = GetAddonServicesResponses[keyof GetAddonServicesResponses];

export type InstallAddonByIdData = {
    body?: never;
    path: {
        /**
         * addon ID
         */
        addonId: string;
    };
    query?: {
        /**
         * service ID
         */
        serviceId?: string;
    };
    url: '/addons/{addonId}/install';
};

export type InstallAddonByIdErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type InstallAddonByIdResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type InstallAddonFromUrlData = {
    body?: never;
    path: {
        /**
         * addon install URL
         */
        url: string;
    };
    query?: never;
    url: '/addons/url/{url}/install';
};

export type InstallAddonFromUrlErrors = {
    /**
     * The given URL is malformed or not valid.
     */
    400: unknown;
};

export type InstallAddonFromUrlResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type UninstallAddonData = {
    body?: never;
    path: {
        /**
         * addon ID
         */
        addonId: string;
    };
    query?: {
        /**
         * service ID
         */
        serviceId?: string;
    };
    url: '/addons/{addonId}/uninstall';
};

export type UninstallAddonErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type UninstallAddonResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetChannelTypesData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path?: never;
    query?: {
        /**
         * filter UIDs by prefix (multiple comma-separated prefixes allowed, for example: 'system,mqtt')
         */
        prefixes?: string;
    };
    url: '/channel-types';
};

export type GetChannelTypesResponses = {
    /**
     * OK
     */
    200: Array<ChannelType>;
};

export type GetChannelTypesResponse = GetChannelTypesResponses[keyof GetChannelTypesResponses];

export type GetChannelTypeByUidData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * channelTypeUID
         */
        channelTypeUID: string;
    };
    query?: never;
    url: '/channel-types/{channelTypeUID}';
};

export type GetChannelTypeByUidErrors = {
    /**
     * No content
     */
    404: unknown;
};

export type GetChannelTypeByUidResponses = {
    /**
     * Channel type with provided channelTypeUID does not exist.
     */
    200: ChannelType;
};

export type GetChannelTypeByUidResponse = GetChannelTypeByUidResponses[keyof GetChannelTypeByUidResponses];

export type GetLinkableItemTypesByChannelTypeUidData = {
    body?: never;
    path: {
        /**
         * channelTypeUID
         */
        channelTypeUID: string;
    };
    query?: never;
    url: '/channel-types/{channelTypeUID}/linkableItemTypes';
};

export type GetLinkableItemTypesByChannelTypeUidErrors = {
    /**
     * Given channel type UID not found.
     */
    404: unknown;
};

export type GetLinkableItemTypesByChannelTypeUidResponses = {
    /**
     * OK
     */
    200: Array<string>;
    /**
     * No content: channel type has no linkable items or is no trigger channel.
     */
    204: void;
};

export type GetLinkableItemTypesByChannelTypeUidResponse = GetLinkableItemTypesByChannelTypeUidResponses[keyof GetLinkableItemTypesByChannelTypeUidResponses];

export type GetConfigDescriptionsData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path?: never;
    query?: {
        /**
         * scheme filter
         */
        scheme?: string;
    };
    url: '/config-descriptions';
};

export type GetConfigDescriptionsResponses = {
    /**
     * OK
     */
    200: Array<ConfigDescription>;
};

export type GetConfigDescriptionsResponse = GetConfigDescriptionsResponses[keyof GetConfigDescriptionsResponses];

export type GetConfigDescriptionByUriData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * uri
         */
        uri: string;
    };
    query?: never;
    url: '/config-descriptions/{uri}';
};

export type GetConfigDescriptionByUriErrors = {
    /**
     * Invalid URI syntax
     */
    400: unknown;
    /**
     * Not found
     */
    404: unknown;
};

export type GetConfigDescriptionByUriResponses = {
    /**
     * OK
     */
    200: ConfigDescription;
};

export type GetConfigDescriptionByUriResponse = GetConfigDescriptionByUriResponses[keyof GetConfigDescriptionByUriResponses];

export type GetBindingsWithDiscoverySupportData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/discovery';
};

export type GetBindingsWithDiscoverySupportResponses = {
    /**
     * OK
     */
    200: Array<string>;
};

export type GetBindingsWithDiscoverySupportResponse = GetBindingsWithDiscoverySupportResponses[keyof GetBindingsWithDiscoverySupportResponses];

export type GetDiscoveryServicesInfoData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * binding Id
         */
        bindingId: string;
    };
    query?: never;
    url: '/discovery/bindings/{bindingId}/info';
};

export type GetDiscoveryServicesInfoErrors = {
    /**
     * Discovery service not found
     */
    404: unknown;
};

export type GetDiscoveryServicesInfoResponses = {
    /**
     * OK
     */
    200: DiscoveryInfo;
};

export type GetDiscoveryServicesInfoResponse = GetDiscoveryServicesInfoResponses[keyof GetDiscoveryServicesInfoResponses];

export type ScanData = {
    body?: never;
    path: {
        /**
         * binding Id
         */
        bindingId: string;
    };
    query?: {
        /**
         * input parameter to start the discovery
         */
        input?: string;
    };
    url: '/discovery/bindings/{bindingId}/scan';
};

export type ScanErrors = {
    /**
     * Discovery service not found
     */
    404: unknown;
};

export type ScanResponses = {
    /**
     * OK
     */
    200: number;
};

export type ScanResponse = ScanResponses[keyof ScanResponses];

export type ApproveInboxItemByIdData = {
    /**
     * thing label
     */
    body?: string;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * thingUID
         */
        thingUID: string;
    };
    query?: {
        /**
         * new thing ID
         */
        newThingId?: string;
    };
    url: '/inbox/{thingUID}/approve';
};

export type ApproveInboxItemByIdErrors = {
    /**
     * Invalid new thing ID.
     */
    400: unknown;
    /**
     * Thing unable to be approved.
     */
    404: unknown;
    /**
     * No binding found that supports this thing.
     */
    409: unknown;
};

export type ApproveInboxItemByIdResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type RemoveItemFromInboxData = {
    body?: never;
    path: {
        /**
         * thingUID
         */
        thingUID: string;
    };
    query?: never;
    url: '/inbox/{thingUID}';
};

export type RemoveItemFromInboxErrors = {
    /**
     * Discovery result not found in the inbox.
     */
    404: unknown;
};

export type RemoveItemFromInboxResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetDiscoveredInboxItemsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * If true, include ignored inbox entries. Defaults to true
         */
        includeIgnored?: boolean;
    };
    url: '/inbox';
};

export type GetDiscoveredInboxItemsResponses = {
    /**
     * OK
     */
    200: Array<DiscoveryResult>;
};

export type GetDiscoveredInboxItemsResponse = GetDiscoveredInboxItemsResponses[keyof GetDiscoveredInboxItemsResponses];

export type FlagInboxItemAsIgnoredData = {
    body?: never;
    path: {
        /**
         * thingUID
         */
        thingUID: string;
    };
    query?: never;
    url: '/inbox/{thingUID}/ignore';
};

export type FlagInboxItemAsIgnoredResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type RemoveIgnoreFlagOnInboxItemData = {
    body?: never;
    path: {
        /**
         * thingUID
         */
        thingUID: string;
    };
    query?: never;
    url: '/inbox/{thingUID}/unignore';
};

export type RemoveIgnoreFlagOnInboxItemResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type CreateData = {
    /**
     * JSON data
     */
    body: FileFormat;
    path?: never;
    query?: {
        /**
         * hide the configuration parameters having the default value
         */
        hideDefaultParameters?: boolean;
        /**
         * hide the non extensible channels having a default configuration
         */
        hideDefaultChannels?: boolean;
        /**
         * hide the channel links and metadata for items
         */
        hideChannelLinksAndMetadata?: boolean;
    };
    url: '/file-format/create';
};

export type CreateErrors = {
    /**
     * Invalid JSON data.
     */
    400: unknown;
    /**
     * Unsupported media type.
     */
    415: unknown;
};

export type CreateResponses = {
    /**
     * OK
     */
    200: string;
};

export type CreateResponse = CreateResponses[keyof CreateResponses];

export type CreateFileFormatForItemsData = {
    /**
     * Array of item names. If empty or omitted, return all Items.
     */
    body?: Array<string>;
    path?: never;
    query?: {
        /**
         * hide the configuration parameters having the default value
         */
        hideDefaultParameters?: boolean;
    };
    url: '/file-format/items';
};

export type CreateFileFormatForItemsErrors = {
    /**
     * One or more items not found in registry.
     */
    404: unknown;
    /**
     * Unsupported media type.
     */
    415: unknown;
};

export type CreateFileFormatForItemsResponses = {
    /**
     * OK
     */
    200: string;
};

export type CreateFileFormatForItemsResponse = CreateFileFormatForItemsResponses[keyof CreateFileFormatForItemsResponses];

export type CreateFileFormatForThingsData = {
    /**
     * Array of Thing UIDs. If empty or omitted, return all Things from the Registry.
     */
    body?: Array<string>;
    path?: never;
    query?: {
        /**
         * hide the configuration parameters having the default value
         */
        hideDefaultParameters?: boolean;
    };
    url: '/file-format/things';
};

export type CreateFileFormatForThingsErrors = {
    /**
     * One or more things not found in registry.
     */
    404: unknown;
    /**
     * Unsupported media type.
     */
    415: unknown;
};

export type CreateFileFormatForThingsResponses = {
    /**
     * OK
     */
    200: string;
};

export type CreateFileFormatForThingsResponse = CreateFileFormatForThingsResponses[keyof CreateFileFormatForThingsResponses];

export type ParseData = {
    /**
     * file format syntax
     */
    body: string;
    path?: never;
    query?: never;
    url: '/file-format/parse';
};

export type ParseErrors = {
    /**
     * Invalid input data.
     */
    400: unknown;
    /**
     * Unsupported content type.
     */
    415: unknown;
};

export type ParseResponses = {
    /**
     * OK
     */
    200: ExtendedFileFormat;
};

export type ParseResponse = ParseResponses[keyof ParseResponses];

export type RemoveMemberFromGroupItemData = {
    body?: never;
    path: {
        /**
         * item name
         */
        itemName: string;
        /**
         * member item name
         */
        memberItemName: string;
    };
    query?: never;
    url: '/items/{itemName}/members/{memberItemName}';
};

export type RemoveMemberFromGroupItemErrors = {
    /**
     * Item or member item not found or item is not of type group item.
     */
    404: unknown;
    /**
     * Member item is not editable.
     */
    405: unknown;
};

export type RemoveMemberFromGroupItemResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type AddMemberToGroupItemData = {
    body?: never;
    path: {
        /**
         * item name
         */
        itemName: string;
        /**
         * member item name
         */
        memberItemName: string;
    };
    query?: never;
    url: '/items/{itemName}/members/{memberItemName}';
};

export type AddMemberToGroupItemErrors = {
    /**
     * Item or member item not found or item is not of type group item.
     */
    404: unknown;
    /**
     * Member item is not editable.
     */
    405: unknown;
};

export type AddMemberToGroupItemResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type RemoveMetadataFromItemData = {
    body?: never;
    path: {
        /**
         * item name
         */
        itemName: string;
        /**
         * namespace
         */
        namespace: string;
    };
    query?: never;
    url: '/items/{itemName}/metadata/{namespace}';
};

export type RemoveMetadataFromItemErrors = {
    /**
     * Item not found.
     */
    404: unknown;
    /**
     * Meta data not editable.
     */
    405: unknown;
};

export type RemoveMetadataFromItemResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type AddMetadataToItemData = {
    /**
     * metadata
     */
    body: Metadata;
    path: {
        /**
         * item name
         */
        itemName: string;
        /**
         * namespace
         */
        namespace: string;
    };
    query?: never;
    url: '/items/{itemName}/metadata/{namespace}';
};

export type AddMetadataToItemErrors = {
    /**
     * Item not found.
     */
    404: unknown;
    /**
     * Metadata not editable.
     */
    405: unknown;
};

export type AddMetadataToItemResponses = {
    /**
     * OK
     */
    200: unknown;
    /**
     * Created
     */
    201: unknown;
};

export type RemoveTagFromItemData = {
    body?: never;
    path: {
        /**
         * item name
         */
        itemName: string;
        /**
         * tag
         */
        tag: string;
    };
    query?: never;
    url: '/items/{itemName}/tags/{tag}';
};

export type RemoveTagFromItemErrors = {
    /**
     * Item not found.
     */
    404: unknown;
    /**
     * Item not editable.
     */
    405: unknown;
};

export type RemoveTagFromItemResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type AddTagToItemData = {
    body?: never;
    path: {
        /**
         * item name
         */
        itemName: string;
        /**
         * tag
         */
        tag: string;
    };
    query?: never;
    url: '/items/{itemName}/tags/{tag}';
};

export type AddTagToItemErrors = {
    /**
     * Item not found.
     */
    404: unknown;
    /**
     * Item not editable.
     */
    405: unknown;
};

export type AddTagToItemResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type RemoveItemFromRegistryData = {
    body?: never;
    path: {
        /**
         * item name
         */
        itemName: string;
    };
    query?: never;
    url: '/items/{itemName}';
};

export type RemoveItemFromRegistryErrors = {
    /**
     * Item not found or item is not editable.
     */
    404: unknown;
};

export type RemoveItemFromRegistryResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetItemByNameData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * item name
         */
        itemName: string;
    };
    query?: {
        /**
         * metadata selector - a comma separated list or a regular expression (returns all if no value given)
         */
        metadata?: string;
        /**
         * get member items if the item is a group item
         */
        recursive?: boolean;
        /**
         * get parent group items recursively
         */
        parents?: boolean;
    };
    url: '/items/{itemName}';
};

export type GetItemByNameErrors = {
    /**
     * Item not found
     */
    404: unknown;
};

export type GetItemByNameResponses = {
    /**
     * OK
     */
    200: EnrichedItem;
};

export type GetItemByNameResponse = GetItemByNameResponses[keyof GetItemByNameResponses];

export type SendItemCommandData = {
    /**
     * Valid item command (e.g., ON, OFF) either as plain text or JSON
     */
    body: string;
    headers?: {
        /**
         * the source of the command; takes priority over the query parameter or JSON body if multiple are set
         */
        'X-OpenHAB-Source'?: string;
    };
    path: {
        /**
         * item name
         */
        itemName: string;
    };
    query?: {
        /**
         * the source of the command
         */
        source?: string;
    };
    url: '/items/{itemName}';
};

export type SendItemCommandErrors = {
    /**
     * Command cannot be parsed
     */
    400: unknown;
    /**
     * Item not found
     */
    404: unknown;
};

export type SendItemCommandResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type AddOrUpdateItemInRegistryData = {
    /**
     * item data
     */
    body: GroupItem;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * item name
         */
        itemName: string;
    };
    query?: never;
    url: '/items/{itemName}';
};

export type AddOrUpdateItemInRegistryErrors = {
    /**
     * Payload invalid.
     */
    400: unknown;
    /**
     * Item not found or name in path invalid.
     */
    404: unknown;
    /**
     * Item not editable.
     */
    405: unknown;
};

export type AddOrUpdateItemInRegistryResponses = {
    /**
     * OK
     */
    200: EnrichedItem;
    /**
     * Item created.
     */
    201: unknown;
};

export type AddOrUpdateItemInRegistryResponse = AddOrUpdateItemInRegistryResponses[keyof AddOrUpdateItemInRegistryResponses];

export type GetItemsData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path?: never;
    query?: {
        /**
         * item type filter
         */
        type?: string;
        /**
         * item tag filter
         */
        tags?: string;
        /**
         * metadata selector - a comma separated list or a regular expression (returns all if no value given)
         */
        metadata?: string;
        /**
         * get member items recursively
         */
        recursive?: boolean;
        /**
         * get parent group items recursively
         */
        parents?: boolean;
        /**
         * limit output to the given fields (comma separated)
         */
        fields?: string;
        /**
         * provides a cacheable list of values not expected to change regularly and checks the If-Modified-Since header, all other parameters are ignored except "metadata"
         */
        staticDataOnly?: boolean;
    };
    url: '/items';
};

export type GetItemsResponses = {
    /**
     * OK
     */
    200: Array<EnrichedItem | EnrichedGroupItem>;
};

export type GetItemsResponse = GetItemsResponses[keyof GetItemsResponses];

export type AddOrUpdateItemsInRegistryData = {
    /**
     * array of item data
     */
    body: Array<GroupItem>;
    path?: never;
    query?: never;
    url: '/items';
};

export type AddOrUpdateItemsInRegistryErrors = {
    /**
     * Payload is invalid.
     */
    400: unknown;
};

export type AddOrUpdateItemsInRegistryResponses = {
    /**
     * OK
     */
    200: string;
};

export type AddOrUpdateItemsInRegistryResponse = AddOrUpdateItemsInRegistryResponses[keyof AddOrUpdateItemsInRegistryResponses];

export type GetItemState1Data = {
    body?: never;
    path: {
        /**
         * item name
         */
        itemName: string;
    };
    query?: never;
    url: '/items/{itemName}/state';
};

export type GetItemState1Errors = {
    /**
     * Item not found
     */
    404: unknown;
};

export type GetItemState1Responses = {
    /**
     * OK
     */
    200: string;
};

export type GetItemState1Response = GetItemState1Responses[keyof GetItemState1Responses];

export type UpdateItemStateData = {
    /**
     * Valid item state (e.g., ON, OFF) either as plain text or JSON
     */
    body: string;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
        /**
         * the source of the event; takes priority over the query parameter or JSON body if multiple are set
         */
        'X-OpenHAB-Source'?: string;
    };
    path: {
        /**
         * item name
         */
        itemName: string;
    };
    query?: {
        /**
         * the source of the event
         */
        source?: string;
    };
    url: '/items/{itemName}/state';
};

export type UpdateItemStateErrors = {
    /**
     * State cannot be parsed
     */
    400: unknown;
    /**
     * Item not found
     */
    404: unknown;
};

export type UpdateItemStateResponses = {
    /**
     * Accepted
     */
    202: unknown;
};

export type GetItemNamespacesData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * item name
         */
        itemName: string;
    };
    query?: never;
    url: '/items/{itemName}/metadata/namespaces';
};

export type GetItemNamespacesErrors = {
    /**
     * Item not found
     */
    404: unknown;
};

export type GetItemNamespacesResponses = {
    /**
     * OK
     */
    200: string;
};

export type GetItemNamespacesResponse = GetItemNamespacesResponses[keyof GetItemNamespacesResponses];

export type GetSemanticItemData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * item name
         */
        itemName: string;
        /**
         * semantic class
         */
        semanticClass: string;
    };
    query?: never;
    url: '/items/{itemName}/semantic/{semanticClass}';
};

export type GetSemanticItemErrors = {
    /**
     * Item not found
     */
    404: unknown;
};

export type GetSemanticItemResponses = {
    /**
     * OK
     */
    200: EnrichedItem;
};

export type GetSemanticItemResponse = GetSemanticItemResponses[keyof GetSemanticItemResponses];

export type GetSemanticsHealthData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/items/semantics/health';
};

export type GetSemanticsHealthErrors = {
    /**
     * Item not found.
     */
    404: unknown;
};

export type GetSemanticsHealthResponses = {
    /**
     * OK
     */
    200: Array<ItemSemanticsProblem>;
};

export type GetSemanticsHealthResponse = GetSemanticsHealthResponses[keyof GetSemanticsHealthResponses];

export type PurgeDatabaseData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/items/metadata/purge';
};

export type PurgeDatabaseResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetItemLinksData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * filter by channel UID
         */
        channelUID?: string;
        /**
         * filter by item name
         */
        itemName?: string;
    };
    url: '/links';
};

export type GetItemLinksResponses = {
    /**
     * OK
     */
    200: Array<EnrichedItemChannelLink>;
};

export type GetItemLinksResponse = GetItemLinksResponses[keyof GetItemLinksResponses];

export type UnlinkItemFromChannelData = {
    body?: never;
    path: {
        /**
         * itemName
         */
        itemName: string;
        /**
         * channelUID
         */
        channelUID: string;
    };
    query?: never;
    url: '/links/{itemName}/{channelUID}';
};

export type UnlinkItemFromChannelErrors = {
    /**
     * Invalid channel UID.
     */
    400: unknown;
    /**
     * Link not found.
     */
    404: unknown;
    /**
     * Link not editable.
     */
    405: unknown;
};

export type UnlinkItemFromChannelResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetItemLinkData = {
    body?: never;
    path: {
        /**
         * item name
         */
        itemName: string;
        /**
         * channel UID
         */
        channelUID: string;
    };
    query?: never;
    url: '/links/{itemName}/{channelUID}';
};

export type GetItemLinkErrors = {
    /**
     * Content does not match the path
     */
    404: unknown;
};

export type GetItemLinkResponses = {
    /**
     * OK
     */
    200: EnrichedItemChannelLink;
};

export type GetItemLinkResponse = GetItemLinkResponses[keyof GetItemLinkResponses];

export type LinkItemToChannelData = {
    /**
     * link data
     */
    body?: ItemChannelLink;
    path: {
        /**
         * itemName
         */
        itemName: string;
        /**
         * channelUID
         */
        channelUID: string;
    };
    query?: never;
    url: '/links/{itemName}/{channelUID}';
};

export type LinkItemToChannelErrors = {
    /**
     * Content does not match the path
     */
    400: unknown;
    /**
     * Link is not editable
     */
    405: unknown;
};

export type LinkItemToChannelResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetOrphanLinksData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/links/orphans';
};

export type GetOrphanLinksResponses = {
    /**
     * OK
     */
    200: Array<BrokenItemChannelLink>;
};

export type GetOrphanLinksResponse = GetOrphanLinksResponses[keyof GetOrphanLinksResponses];

export type PurgeDatabase1Data = {
    body?: never;
    path?: never;
    query?: never;
    url: '/links/purge';
};

export type PurgeDatabase1Responses = {
    /**
     * OK
     */
    200: unknown;
};

export type RemoveAllLinksForObjectData = {
    body?: never;
    path: {
        /**
         * item name or thing UID
         */
        object: string;
    };
    query?: never;
    url: '/links/{object}';
};

export type RemoveAllLinksForObjectResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type DeletePersistenceServiceConfigurationData = {
    body?: never;
    path: {
        /**
         * Id of the persistence service.
         */
        serviceId: string;
    };
    query?: never;
    url: '/persistence/{serviceId}';
};

export type DeletePersistenceServiceConfigurationErrors = {
    /**
     * Persistence service configuration not found.
     */
    404: unknown;
    /**
     * Persistence service configuration not editable.
     */
    405: unknown;
};

export type DeletePersistenceServiceConfigurationResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetPersistenceServiceConfigurationData = {
    body?: never;
    path: {
        /**
         * Id of the persistence service.
         */
        serviceId: string;
    };
    query?: never;
    url: '/persistence/{serviceId}';
};

export type GetPersistenceServiceConfigurationErrors = {
    /**
     * Service configuration not found.
     */
    404: unknown;
};

export type GetPersistenceServiceConfigurationResponses = {
    /**
     * OK
     */
    200: PersistenceServiceConfiguration;
};

export type GetPersistenceServiceConfigurationResponse = GetPersistenceServiceConfigurationResponses[keyof GetPersistenceServiceConfigurationResponses];

export type PutPersistenceServiceConfigurationData = {
    /**
     * service configuration
     */
    body: PersistenceServiceConfiguration;
    path: {
        /**
         * Id of the persistence service.
         */
        serviceId: string;
    };
    query?: never;
    url: '/persistence/{serviceId}';
};

export type PutPersistenceServiceConfigurationErrors = {
    /**
     * Payload invalid.
     */
    400: unknown;
    /**
     * PersistenceServiceConfiguration not editable.
     */
    405: unknown;
};

export type PutPersistenceServiceConfigurationResponses = {
    /**
     * OK
     */
    200: PersistenceServiceConfiguration;
    /**
     * PersistenceServiceConfiguration created.
     */
    201: unknown;
};

export type PutPersistenceServiceConfigurationResponse = PutPersistenceServiceConfigurationResponses[keyof PutPersistenceServiceConfigurationResponses];

export type DeleteItemFromPersistenceServiceData = {
    body?: never;
    path: {
        /**
         * The item name.
         */
        itemName: string;
    };
    query: {
        /**
         * Id of the persistence service.
         */
        serviceId: string;
        /**
         * Start of the time range to be deleted. [yyyy-MM-dd'T'HH:mm:ss.SSSZ]
         */
        starttime: string;
        /**
         * End of the time range to be deleted. [yyyy-MM-dd'T'HH:mm:ss.SSSZ]
         */
        endtime: string;
    };
    url: '/persistence/items/{itemName}';
};

export type DeleteItemFromPersistenceServiceErrors = {
    /**
     * Invalid filter parameters
     */
    400: unknown;
    /**
     * Unknown persistence service
     */
    404: unknown;
};

export type DeleteItemFromPersistenceServiceResponses = {
    /**
     * OK
     */
    200: Array<string>;
};

export type DeleteItemFromPersistenceServiceResponse = DeleteItemFromPersistenceServiceResponses[keyof DeleteItemFromPersistenceServiceResponses];

export type GetItemDataFromPersistenceServiceData = {
    body?: never;
    path: {
        /**
         * The item name
         */
        itemName: string;
    };
    query?: {
        /**
         * Id of the persistence service. If not provided the default service will be used
         */
        serviceId?: string;
        /**
         * Start time of the data to return. Will default to 1 day before endtime. [yyyy-MM-dd'T'HH:mm:ss.SSSZ]
         */
        starttime?: string;
        /**
         * End time of the data to return. Will default to current time. [yyyy-MM-dd'T'HH:mm:ss.SSSZ]
         */
        endtime?: string;
        /**
         * Page number of data to return. This parameter will enable paging.
         */
        page?: number;
        /**
         * The length of each page.
         */
        pagelength?: number;
        /**
         * Gets one value before and after the requested period.
         */
        boundary?: boolean;
        /**
         * Adds the current Item state into the requested period (the item state will be before or at the endtime)
         */
        itemState?: boolean;
    };
    url: '/persistence/items/{itemName}';
};

export type GetItemDataFromPersistenceServiceErrors = {
    /**
     * Unknown Item or persistence service
     */
    404: unknown;
};

export type GetItemDataFromPersistenceServiceResponses = {
    /**
     * OK
     */
    200: ItemHistory;
};

export type GetItemDataFromPersistenceServiceResponse = GetItemDataFromPersistenceServiceResponses[keyof GetItemDataFromPersistenceServiceResponses];

export type StoreItemDataInPersistenceServiceData = {
    body?: never;
    path: {
        /**
         * The item name.
         */
        itemName: string;
    };
    query: {
        /**
         * Id of the persistence service. If not provided the default service will be used
         */
        serviceId?: string;
        /**
         * Time of the data to be stored. Will default to current time. [yyyy-MM-dd'T'HH:mm:ss.SSSZ]
         */
        time: string;
        /**
         * The state to store.
         */
        state: string;
    };
    url: '/persistence/items/{itemName}';
};

export type StoreItemDataInPersistenceServiceErrors = {
    /**
     * Item not found, invalid state, invalid time format, or persistence service not found or not modifiable.
     */
    400: unknown;
    /**
     * Unknown Item or persistence service
     */
    404: unknown;
};

export type StoreItemDataInPersistenceServiceResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetPersistenceHealthData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/persistence/health';
};

export type GetPersistenceHealthResponses = {
    /**
     * OK
     */
    200: Array<PersistenceServiceProblem>;
};

export type GetPersistenceHealthResponse = GetPersistenceHealthResponses[keyof GetPersistenceHealthResponses];

export type GetItemsForPersistenceServiceData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Id of the persistence service. If not provided the default service will be used
         */
        serviceId?: string;
    };
    url: '/persistence/items';
};

export type GetItemsForPersistenceServiceResponses = {
    /**
     * OK
     */
    200: Array<PersistenceItemInfo>;
};

export type GetItemsForPersistenceServiceResponse = GetItemsForPersistenceServiceResponses[keyof GetItemsForPersistenceServiceResponses];

export type GetPersistenceServiceStrategySuggestionsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Id of the persistence service.
         */
        serviceId?: string;
    };
    url: '/persistence/strategysuggestions';
};

export type GetPersistenceServiceStrategySuggestionsErrors = {
    /**
     * Suggested strategies not found.
     */
    404: unknown;
};

export type GetPersistenceServiceStrategySuggestionsResponses = {
    /**
     * OK
     */
    200: Array<PersistenceStrategy>;
};

export type GetPersistenceServiceStrategySuggestionsResponse = GetPersistenceServiceStrategySuggestionsResponses[keyof GetPersistenceServiceStrategySuggestionsResponses];

export type GetPersistenceServicesData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path?: never;
    query?: never;
    url: '/persistence';
};

export type GetPersistenceServicesResponses = {
    /**
     * OK
     */
    200: Array<PersistenceService>;
};

export type GetPersistenceServicesResponse = GetPersistenceServicesResponses[keyof GetPersistenceServicesResponses];

export type GetProfileTypesData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path?: never;
    query?: {
        /**
         * channel type filter
         */
        channelTypeUID?: string;
        /**
         * item type filter
         */
        itemType?: string;
    };
    url: '/profile-types';
};

export type GetProfileTypesResponses = {
    /**
     * OK
     */
    200: Array<ProfileType>;
};

export type GetProfileTypesResponse = GetProfileTypesResponses[keyof GetProfileTypesResponses];

export type DeleteServiceConfigData = {
    body?: never;
    path: {
        /**
         * service ID
         */
        serviceId: string;
    };
    query?: never;
    url: '/services/{serviceId}/config';
};

export type DeleteServiceConfigErrors = {
    /**
     * Configuration can not be deleted due to internal error
     */
    500: unknown;
};

export type DeleteServiceConfigResponses = {
    /**
     * OK
     */
    200: string;
    /**
     * No old configuration
     */
    204: void;
};

export type DeleteServiceConfigResponse = DeleteServiceConfigResponses[keyof DeleteServiceConfigResponses];

export type GetServiceConfigData = {
    body?: never;
    path: {
        /**
         * service ID
         */
        serviceId: string;
    };
    query?: never;
    url: '/services/{serviceId}/config';
};

export type GetServiceConfigErrors = {
    /**
     * Configuration can not be read due to internal error
     */
    500: unknown;
};

export type GetServiceConfigResponses = {
    /**
     * OK
     */
    200: string;
};

export type GetServiceConfigResponse = GetServiceConfigResponses[keyof GetServiceConfigResponses];

export type UpdateServiceConfigData = {
    body?: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * service ID
         */
        serviceId: string;
    };
    query?: never;
    url: '/services/{serviceId}/config';
};

export type UpdateServiceConfigErrors = {
    /**
     * Configuration can not be updated due to internal error
     */
    500: unknown;
};

export type UpdateServiceConfigResponses = {
    /**
     * OK
     */
    200: string;
    /**
     * No old configuration
     */
    204: void;
};

export type UpdateServiceConfigResponse = UpdateServiceConfigResponses[keyof UpdateServiceConfigResponses];

export type GetServicesData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path?: never;
    query?: never;
    url: '/services';
};

export type GetServicesResponses = {
    /**
     * OK
     */
    200: Array<ConfigurableService>;
};

export type GetServicesResponse = GetServicesResponses[keyof GetServicesResponses];

export type GetServicesByIdData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * service ID
         */
        serviceId: string;
    };
    query?: never;
    url: '/services/{serviceId}';
};

export type GetServicesByIdErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type GetServicesByIdResponses = {
    /**
     * OK
     */
    200: ConfigurableService;
};

export type GetServicesByIdResponse = GetServicesByIdResponses[keyof GetServicesByIdResponses];

export type GetServiceContextData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * service ID
         */
        serviceId: string;
    };
    query?: never;
    url: '/services/{serviceId}/contexts';
};

export type GetServiceContextResponses = {
    /**
     * OK
     */
    200: Array<ConfigurableService>;
};

export type GetServiceContextResponse = GetServiceContextResponses[keyof GetServiceContextResponses];

export type GetSemanticTagsData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path?: never;
    query?: never;
    url: '/tags';
};

export type GetSemanticTagsResponses = {
    /**
     * OK
     */
    200: Array<EnrichedSemanticTag>;
};

export type GetSemanticTagsResponse = GetSemanticTagsResponses[keyof GetSemanticTagsResponses];

export type CreateSemanticTagData = {
    /**
     * tag data
     */
    body: EnrichedSemanticTag;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path?: never;
    query?: never;
    url: '/tags';
};

export type CreateSemanticTagErrors = {
    /**
     * The tag identifier is invalid or the tag label is missing.
     */
    400: unknown;
    /**
     * A tag with the same identifier already exists.
     */
    409: unknown;
};

export type CreateSemanticTagResponses = {
    /**
     * Created
     */
    201: EnrichedSemanticTag;
};

export type CreateSemanticTagResponse = CreateSemanticTagResponses[keyof CreateSemanticTagResponses];

export type RemoveSemanticTagData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * tag id
         */
        tagId: string;
    };
    query?: never;
    url: '/tags/{tagId}';
};

export type RemoveSemanticTagErrors = {
    /**
     * Semantic tag not found.
     */
    404: unknown;
    /**
     * Semantic tag not removable.
     */
    405: unknown;
};

export type RemoveSemanticTagResponses = {
    /**
     * OK, was deleted.
     */
    200: unknown;
};

export type GetSemanticTagAndSubTagsData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * tag id
         */
        tagId: string;
    };
    query?: never;
    url: '/tags/{tagId}';
};

export type GetSemanticTagAndSubTagsErrors = {
    /**
     * Semantic tag not found.
     */
    404: unknown;
};

export type GetSemanticTagAndSubTagsResponses = {
    /**
     * OK
     */
    200: Array<EnrichedSemanticTag>;
};

export type GetSemanticTagAndSubTagsResponse = GetSemanticTagAndSubTagsResponses[keyof GetSemanticTagAndSubTagsResponses];

export type UpdateSemanticTagData = {
    /**
     * tag data
     */
    body: EnrichedSemanticTag;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * tag id
         */
        tagId: string;
    };
    query?: never;
    url: '/tags/{tagId}';
};

export type UpdateSemanticTagErrors = {
    /**
     * Semantic tag not found.
     */
    404: unknown;
    /**
     * Semantic tag not editable.
     */
    405: unknown;
};

export type UpdateSemanticTagResponses = {
    /**
     * OK
     */
    200: EnrichedSemanticTag;
};

export type UpdateSemanticTagResponse = UpdateSemanticTagResponses[keyof UpdateSemanticTagResponses];

export type GetThingsData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path?: never;
    query?: {
        /**
         * summary fields only
         */
        summary?: boolean;
        /**
         * provides a cacheable list of values not expected to change regularly and checks the If-Modified-Since header
         */
        staticDataOnly?: boolean;
    };
    url: '/things';
};

export type GetThingsResponses = {
    /**
     * OK
     */
    200: Array<EnrichedThing>;
};

export type GetThingsResponse = GetThingsResponses[keyof GetThingsResponses];

export type CreateThingInRegistryData = {
    /**
     * thing data
     */
    body: Thing;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path?: never;
    query?: never;
    url: '/things';
};

export type CreateThingInRegistryErrors = {
    /**
     * A uid must be provided, if no binding can create a thing of this type.
     */
    400: unknown;
    /**
     * A thing with the same uid already exists.
     */
    409: unknown;
};

export type CreateThingInRegistryResponses = {
    /**
     * Created
     */
    201: EnrichedThing;
};

export type CreateThingInRegistryResponse = CreateThingInRegistryResponses[keyof CreateThingInRegistryResponses];

export type RemoveThingByIdData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * thingUID
         */
        thingUID: string;
    };
    query?: {
        /**
         * force
         */
        force?: boolean;
    };
    url: '/things/{thingUID}';
};

export type RemoveThingByIdErrors = {
    /**
     * Thing not found.
     */
    404: unknown;
    /**
     * Thing could not be deleted because it's not editable.
     */
    409: unknown;
};

export type RemoveThingByIdResponses = {
    /**
     * OK, was deleted.
     */
    200: unknown;
    /**
     * ACCEPTED for asynchronous deletion.
     */
    202: unknown;
};

export type GetThingByIdData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * thingUID
         */
        thingUID: string;
    };
    query?: never;
    url: '/things/{thingUID}';
};

export type GetThingByIdErrors = {
    /**
     * Thing not found.
     */
    404: unknown;
};

export type GetThingByIdResponses = {
    /**
     * OK
     */
    200: EnrichedThing;
};

export type GetThingByIdResponse = GetThingByIdResponses[keyof GetThingByIdResponses];

export type UpdateThingData = {
    /**
     * thing
     */
    body: Thing;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * thingUID
         */
        thingUID: string;
    };
    query?: never;
    url: '/things/{thingUID}';
};

export type UpdateThingErrors = {
    /**
     * Thing not found.
     */
    404: unknown;
    /**
     * Thing could not be updated as it is not editable.
     */
    409: unknown;
};

export type UpdateThingResponses = {
    /**
     * OK
     */
    200: EnrichedThing;
};

export type UpdateThingResponse = UpdateThingResponses[keyof UpdateThingResponses];

export type GetThingConfigStatusData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * thing
         */
        thingUID: string;
    };
    query?: never;
    url: '/things/{thingUID}/config/status';
};

export type GetThingConfigStatusErrors = {
    /**
     * Thing not found.
     */
    404: unknown;
};

export type GetThingConfigStatusResponses = {
    /**
     * OK
     */
    200: Array<ConfigStatusMessage>;
};

export type GetThingConfigStatusResponse = GetThingConfigStatusResponses[keyof GetThingConfigStatusResponses];

export type GetThingFirmwareStatusData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * thing
         */
        thingUID: string;
    };
    query?: never;
    url: '/things/{thingUID}/firmware/status';
};

export type GetThingFirmwareStatusResponses = {
    /**
     * OK
     */
    200: FirmwareStatus;
    /**
     * No firmware status provided by this Thing.
     */
    204: void;
};

export type GetThingFirmwareStatusResponse = GetThingFirmwareStatusResponses[keyof GetThingFirmwareStatusResponses];

export type GetAvailableFirmwaresForThingData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * thingUID
         */
        thingUID: string;
    };
    query?: never;
    url: '/things/{thingUID}/firmwares';
};

export type GetAvailableFirmwaresForThingResponses = {
    /**
     * OK
     */
    200: Array<Firmware>;
    /**
     * No firmwares found.
     */
    204: void;
};

export type GetAvailableFirmwaresForThingResponse = GetAvailableFirmwaresForThingResponses[keyof GetAvailableFirmwaresForThingResponses];

export type GetThingStatusData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * thing
         */
        thingUID: string;
    };
    query?: never;
    url: '/things/{thingUID}/status';
};

export type GetThingStatusErrors = {
    /**
     * Thing not found.
     */
    404: unknown;
};

export type GetThingStatusResponses = {
    /**
     * OK
     */
    200: ThingStatusInfo;
};

export type GetThingStatusResponse = GetThingStatusResponses[keyof GetThingStatusResponses];

export type EnableThingData = {
    /**
     * enabled
     */
    body?: string;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * thing
         */
        thingUID: string;
    };
    query?: never;
    url: '/things/{thingUID}/enable';
};

export type EnableThingErrors = {
    /**
     * Thing not found.
     */
    404: unknown;
};

export type EnableThingResponses = {
    /**
     * OK
     */
    200: EnrichedThing;
};

export type EnableThingResponse = EnableThingResponses[keyof EnableThingResponses];

export type UpdateThingConfigData = {
    /**
     * configuration parameters
     */
    body?: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * thing
         */
        thingUID: string;
    };
    query?: never;
    url: '/things/{thingUID}/config';
};

export type UpdateThingConfigErrors = {
    /**
     * Configuration of the thing is not valid.
     */
    400: unknown;
    /**
     * Thing not found
     */
    404: unknown;
    /**
     * Thing could not be updated as it is not editable.
     */
    409: unknown;
};

export type UpdateThingConfigResponses = {
    /**
     * OK
     */
    200: EnrichedThing;
};

export type UpdateThingConfigResponse = UpdateThingConfigResponses[keyof UpdateThingConfigResponses];

export type UpdateThingFirmwareData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * thing
         */
        thingUID: string;
        /**
         * version
         */
        firmwareVersion: string;
    };
    query?: never;
    url: '/things/{thingUID}/firmware/{firmwareVersion}';
};

export type UpdateThingFirmwareErrors = {
    /**
     * Firmware update preconditions not satisfied.
     */
    400: unknown;
    /**
     * Thing not found.
     */
    404: unknown;
};

export type UpdateThingFirmwareResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetThingTypesData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path?: never;
    query?: {
        /**
         * filter by binding Id
         */
        bindingId?: string;
    };
    url: '/thing-types';
};

export type GetThingTypesResponses = {
    /**
     * OK
     */
    200: Array<StrippedThingType>;
};

export type GetThingTypesResponse = GetThingTypesResponses[keyof GetThingTypesResponses];

export type GetThingTypeByIdData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * thingTypeUID
         */
        thingTypeUID: string;
    };
    query?: never;
    url: '/thing-types/{thingTypeUID}';
};

export type GetThingTypeByIdErrors = {
    /**
     * No content
     */
    404: unknown;
};

export type GetThingTypeByIdResponses = {
    /**
     * Thing type with provided thingTypeUID does not exist.
     */
    200: ThingType;
};

export type GetThingTypeByIdResponse = GetThingTypeByIdResponses[keyof GetThingTypeByIdResponses];

export type GetRootData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/';
};

export type GetRootResponses = {
    /**
     * OK
     */
    200: RootBean;
};

export type GetRootResponse = GetRootResponses[keyof GetRootResponses];

export type GetSystemInformationData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/systeminfo';
};

export type GetSystemInformationResponses = {
    /**
     * OK
     */
    200: SystemInfoBean;
};

export type GetSystemInformationResponse = GetSystemInformationResponses[keyof GetSystemInformationResponses];

export type GetUoMInformationData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/systeminfo/uom';
};

export type GetUoMInformationResponses = {
    /**
     * OK
     */
    200: UoMInfoBean;
};

export type GetUoMInformationResponse = GetUoMInformationResponses[keyof GetUoMInformationResponses];

export type CreateSitemapEventSubscriptionData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sitemaps/events/subscribe';
};

export type CreateSitemapEventSubscriptionErrors = {
    /**
     * Subscriptions limit reached.
     */
    503: unknown;
};

export type CreateSitemapEventSubscriptionResponses = {
    /**
     * Subscription created.
     */
    201: unknown;
};

export type PollDataForPageData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * sitemap name
         */
        sitemapname: string;
        /**
         * page id
         */
        pageid: string;
    };
    query?: {
        /**
         * subscriptionid
         */
        subscriptionid?: string;
        /**
         * include hidden widgets
         */
        includeHidden?: boolean;
    };
    url: '/sitemaps/{sitemapname}/{pageid}';
};

export type PollDataForPageErrors = {
    /**
     * Invalid subscription id has been provided.
     */
    400: unknown;
    /**
     * Sitemap with requested name does not exist or page does not exist, or page refers to a non-linkable widget
     */
    404: unknown;
};

export type PollDataForPageResponses = {
    /**
     * OK
     */
    200: Page;
};

export type PollDataForPageResponse = PollDataForPageResponses[keyof PollDataForPageResponses];

export type PollDataForSitemapData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * sitemap name
         */
        sitemapname: string;
    };
    query?: {
        /**
         * subscriptionid
         */
        subscriptionid?: string;
        /**
         * include hidden widgets
         */
        includeHidden?: boolean;
    };
    url: '/sitemaps/{sitemapname}/*';
};

export type PollDataForSitemapErrors = {
    /**
     * Invalid subscription id has been provided.
     */
    400: unknown;
    /**
     * Sitemap with requested name does not exist
     */
    404: unknown;
};

export type PollDataForSitemapResponses = {
    /**
     * OK
     */
    200: Sitemap;
};

export type PollDataForSitemapResponse = PollDataForSitemapResponses[keyof PollDataForSitemapResponses];

export type GetSitemapByNameData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * sitemap name
         */
        sitemapname: string;
    };
    query?: {
        type?: string;
        jsoncallback?: string;
        /**
         * include hidden widgets
         */
        includeHidden?: boolean;
    };
    url: '/sitemaps/{sitemapname}';
};

export type GetSitemapByNameResponses = {
    /**
     * OK
     */
    200: Sitemap;
};

export type GetSitemapByNameResponse = GetSitemapByNameResponses[keyof GetSitemapByNameResponses];

export type GetSitemapEventsData = {
    body?: never;
    path: {
        /**
         * subscription id
         */
        subscriptionid: string;
    };
    query?: {
        /**
         * sitemap name
         */
        sitemap?: string;
    };
    url: '/sitemaps/events/{subscriptionid}/*';
};

export type GetSitemapEventsErrors = {
    /**
     * Missing sitemap parameter, or sitemap not linked successfully to the subscription.
     */
    400: unknown;
    /**
     * Subscription not found.
     */
    404: unknown;
};

export type GetSitemapEventsResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetSitemapEvents1Data = {
    body?: never;
    path: {
        /**
         * subscription id
         */
        subscriptionid: string;
    };
    query?: {
        /**
         * sitemap name
         */
        sitemap?: string;
        /**
         * page id
         */
        pageid?: string;
    };
    url: '/sitemaps/events/{subscriptionid}';
};

export type GetSitemapEvents1Errors = {
    /**
     * Missing sitemap or page parameter, or page not linked successfully to the subscription.
     */
    400: unknown;
    /**
     * Subscription not found.
     */
    404: unknown;
};

export type GetSitemapEvents1Responses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetSitemapsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sitemaps';
};

export type GetSitemapsResponses = {
    /**
     * OK
     */
    200: Array<Sitemap>;
};

export type GetSitemapsResponse = GetSitemapsResponses[keyof GetSitemapsResponses];

export type InitNewStateTackerData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/events/states';
};

export type InitNewStateTackerResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetEventsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * topics
         */
        topics?: string;
    };
    url: '/events';
};

export type GetEventsErrors = {
    /**
     * Topic is empty or contains invalid characters
     */
    400: unknown;
};

export type GetEventsResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type UpdateItemListForStateUpdatesData = {
    /**
     * items
     */
    body?: Array<string>;
    path: {
        connectionId: string;
    };
    query?: never;
    url: '/events/states/{connectionId}';
};

export type UpdateItemListForStateUpdatesErrors = {
    /**
     * Unknown connectionId
     */
    404: unknown;
};

export type UpdateItemListForStateUpdatesResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type DeleteTransformationData = {
    body?: never;
    path: {
        /**
         * Transformation UID
         */
        uid: string;
    };
    query?: never;
    url: '/transformations/{uid}';
};

export type DeleteTransformationErrors = {
    /**
     * UID not found
     */
    404: unknown;
    /**
     * Transformation not editable
     */
    405: unknown;
};

export type DeleteTransformationResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetTransformationData = {
    body?: never;
    path: {
        /**
         * Transformation UID
         */
        uid: string;
    };
    query?: never;
    url: '/transformations/{uid}';
};

export type GetTransformationErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type GetTransformationResponses = {
    /**
     * OK
     */
    200: Transformation;
};

export type GetTransformationResponse = GetTransformationResponses[keyof GetTransformationResponses];

export type PutTransformationData = {
    /**
     * transformation
     */
    body: Transformation;
    path: {
        /**
         * Transformation UID
         */
        uid: string;
    };
    query?: never;
    url: '/transformations/{uid}';
};

export type PutTransformationErrors = {
    /**
     * Bad Request (content missing or invalid)
     */
    400: unknown;
    /**
     * Transformation not editable
     */
    405: unknown;
};

export type PutTransformationResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetTransformationServicesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/transformations/services';
};

export type GetTransformationServicesResponses = {
    /**
     * OK
     */
    200: Array<string>;
};

export type GetTransformationServicesResponse = GetTransformationServicesResponses[keyof GetTransformationServicesResponses];

export type GetTransformationsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/transformations';
};

export type GetTransformationsResponses = {
    /**
     * OK
     */
    200: Array<Transformation>;
};

export type GetTransformationsResponse = GetTransformationsResponses[keyof GetTransformationsResponses];

export type GetRegisteredUiComponentsInNamespaceData = {
    body?: never;
    path: {
        namespace: string;
    };
    query?: {
        /**
         * summary fields only
         */
        summary?: boolean;
    };
    url: '/ui/components/{namespace}';
};

export type GetRegisteredUiComponentsInNamespaceResponses = {
    /**
     * OK
     */
    200: Array<RootUiComponent>;
};

export type GetRegisteredUiComponentsInNamespaceResponse = GetRegisteredUiComponentsInNamespaceResponses[keyof GetRegisteredUiComponentsInNamespaceResponses];

export type AddUiComponentToNamespaceData = {
    body?: RootUiComponent;
    path: {
        namespace: string;
    };
    query?: never;
    url: '/ui/components/{namespace}';
};

export type AddUiComponentToNamespaceResponses = {
    /**
     * OK
     */
    200: RootUiComponent;
};

export type AddUiComponentToNamespaceResponse = AddUiComponentToNamespaceResponses[keyof AddUiComponentToNamespaceResponses];

export type RemoveUiComponentFromNamespaceData = {
    body?: never;
    path: {
        namespace: string;
        componentUID: string;
    };
    query?: never;
    url: '/ui/components/{namespace}/{componentUID}';
};

export type RemoveUiComponentFromNamespaceErrors = {
    /**
     * Component not found
     */
    404: unknown;
};

export type RemoveUiComponentFromNamespaceResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetUiComponentInNamespaceData = {
    body?: never;
    path: {
        namespace: string;
        componentUID: string;
    };
    query?: never;
    url: '/ui/components/{namespace}/{componentUID}';
};

export type GetUiComponentInNamespaceErrors = {
    /**
     * Component not found
     */
    404: unknown;
};

export type GetUiComponentInNamespaceResponses = {
    /**
     * OK
     */
    200: RootUiComponent;
};

export type GetUiComponentInNamespaceResponse = GetUiComponentInNamespaceResponses[keyof GetUiComponentInNamespaceResponses];

export type UpdateUiComponentInNamespaceData = {
    body?: RootUiComponent;
    path: {
        namespace: string;
        componentUID: string;
    };
    query?: never;
    url: '/ui/components/{namespace}/{componentUID}';
};

export type UpdateUiComponentInNamespaceErrors = {
    /**
     * Component not found
     */
    404: unknown;
};

export type UpdateUiComponentInNamespaceResponses = {
    /**
     * OK
     */
    200: RootUiComponent;
};

export type UpdateUiComponentInNamespaceResponse = UpdateUiComponentInNamespaceResponses[keyof UpdateUiComponentInNamespaceResponses];

export type GetUiTilesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/ui/tiles';
};

export type GetUiTilesResponses = {
    /**
     * OK
     */
    200: Array<Tile>;
};

export type GetUiTilesResponse = GetUiTilesResponses[keyof GetUiTilesResponses];

export type GetDefaultVoiceData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/voice/defaultvoice';
};

export type GetDefaultVoiceErrors = {
    /**
     * No default voice was found.
     */
    404: unknown;
};

export type GetDefaultVoiceResponses = {
    /**
     * OK
     */
    200: Voice;
};

export type GetDefaultVoiceResponse = GetDefaultVoiceResponses[keyof GetDefaultVoiceResponses];

export type GetVoiceInterpreterByUidData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * interpreter id
         */
        id: string;
    };
    query?: never;
    url: '/voice/interpreters/{id}';
};

export type GetVoiceInterpreterByUidErrors = {
    /**
     * Interpreter not found
     */
    404: unknown;
};

export type GetVoiceInterpreterByUidResponses = {
    /**
     * OK
     */
    200: Array<HumanLanguageInterpreter>;
};

export type GetVoiceInterpreterByUidResponse = GetVoiceInterpreterByUidResponses[keyof GetVoiceInterpreterByUidResponses];

export type GetVoiceInterpretersData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path?: never;
    query?: never;
    url: '/voice/interpreters';
};

export type GetVoiceInterpretersResponses = {
    /**
     * OK
     */
    200: Array<HumanLanguageInterpreter>;
};

export type GetVoiceInterpretersResponse = GetVoiceInterpretersResponses[keyof GetVoiceInterpretersResponses];

export type InterpretTextByDefaultInterpreterData = {
    /**
     * text to interpret
     */
    body: string;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path?: never;
    query?: never;
    url: '/voice/interpreters';
};

export type InterpretTextByDefaultInterpreterErrors = {
    /**
     * interpretation exception occurs
     */
    400: unknown;
    /**
     * No human language interpreter was found.
     */
    404: unknown;
};

export type InterpretTextByDefaultInterpreterResponses = {
    /**
     * OK
     */
    200: string;
};

export type InterpretTextByDefaultInterpreterResponse = InterpretTextByDefaultInterpreterResponses[keyof InterpretTextByDefaultInterpreterResponses];

export type GetVoicesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/voice/voices';
};

export type GetVoicesResponses = {
    /**
     * OK
     */
    200: Array<Voice>;
};

export type GetVoicesResponse = GetVoicesResponses[keyof GetVoicesResponses];

export type InterpretTextData = {
    /**
     * text to interpret
     */
    body: string;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * comma separated list of interpreter ids
         */
        ids: Array<string>;
    };
    query?: never;
    url: '/voice/interpreters/{ids}';
};

export type InterpretTextErrors = {
    /**
     * interpretation exception occurs
     */
    400: unknown;
    /**
     * No human language interpreter was found.
     */
    404: unknown;
};

export type InterpretTextResponses = {
    /**
     * OK
     */
    200: string;
};

export type InterpretTextResponse = InterpretTextResponses[keyof InterpretTextResponses];

export type ListenAndAnswerData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path?: never;
    query?: {
        /**
         * source ID
         */
        sourceId?: string;
        /**
         * Speech-to-Text ID
         */
        sttId?: string;
        /**
         * Text-to-Speech ID
         */
        ttsId?: string;
        /**
         * voice ID
         */
        voiceId?: string;
        /**
         * interpreter IDs
         */
        hliIds?: Array<string>;
        /**
         * audio sink ID
         */
        sinkId?: string;
        /**
         * listening item
         */
        listeningItem?: string;
    };
    url: '/voice/listenandanswer';
};

export type ListenAndAnswerErrors = {
    /**
     * Services are missing or language is not supported by services or dialog processing is already started for the audio source.
     */
    400: unknown;
    /**
     * One of the given ids is wrong.
     */
    404: unknown;
};

export type ListenAndAnswerResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type TextToSpeechData = {
    /**
     * text to speak
     */
    body: string;
    path?: never;
    query?: {
        /**
         * voice id
         */
        voiceid?: string;
        /**
         * audio sink id
         */
        sinkid?: string;
        /**
         * volume level
         */
        volume?: string;
    };
    url: '/voice/say';
};

export type TextToSpeechResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type StartDialogData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path?: never;
    query?: {
        /**
         * source ID
         */
        sourceId?: string;
        /**
         * keywork spotter ID
         */
        ksId?: string;
        /**
         * Speech-to-Text ID
         */
        sttId?: string;
        /**
         * Text-to-Speech ID
         */
        ttsId?: string;
        /**
         * voice ID
         */
        voiceId?: string;
        /**
         * comma separated list of interpreter IDs
         */
        hliIds?: string;
        /**
         * audio sink ID
         */
        sinkId?: string;
        /**
         * keyword
         */
        keyword?: string;
        /**
         * listening item
         */
        listeningItem?: string;
    };
    url: '/voice/dialog/start';
};

export type StartDialogErrors = {
    /**
     * Services are missing or language is not supported by services or dialog processing is already started for the audio source.
     */
    400: unknown;
    /**
     * One of the given ids is wrong.
     */
    404: unknown;
};

export type StartDialogResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type StopDialogData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * source ID
         */
        sourceId?: string;
    };
    url: '/voice/dialog/stop';
};

export type StopDialogErrors = {
    /**
     * No dialog processing is started for the audio source.
     */
    400: unknown;
    /**
     * No audio source was found.
     */
    404: unknown;
};

export type StopDialogResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type RemoveLoggerData = {
    body?: never;
    path: {
        /**
         * logger name
         */
        loggerName: string;
    };
    query?: never;
    url: '/logging/{loggerName}';
};

export type RemoveLoggerResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetLoggerData = {
    body?: never;
    path: {
        /**
         * logger name
         */
        loggerName: string;
    };
    query?: never;
    url: '/logging/{loggerName}';
};

export type GetLoggerResponses = {
    /**
     * OK
     */
    200: LoggerInfo;
};

export type GetLoggerResponse = GetLoggerResponses[keyof GetLoggerResponses];

export type PutLoggerData = {
    /**
     * logger
     */
    body: LoggerInfo;
    path: {
        /**
         * logger name
         */
        loggerName: string;
    };
    query?: never;
    url: '/logging/{loggerName}';
};

export type PutLoggerErrors = {
    /**
     * Payload is invalid.
     */
    400: unknown;
};

export type PutLoggerResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetLogger1Data = {
    body?: never;
    path?: never;
    query?: never;
    url: '/logging';
};

export type GetLogger1Responses = {
    /**
     * OK
     */
    200: LoggerBean;
};

export type GetLogger1Response = GetLogger1Responses[keyof GetLogger1Responses];

export type GetIconSetsData = {
    body?: never;
    headers?: {
        /**
         * language
         */
        'Accept-Language'?: string;
    };
    path?: never;
    query?: never;
    url: '/iconsets';
};

export type GetIconSetsResponses = {
    /**
     * OK
     */
    200: Array<IconSet>;
};

export type GetIconSetsResponse = GetIconSetsResponses[keyof GetIconSetsResponses];

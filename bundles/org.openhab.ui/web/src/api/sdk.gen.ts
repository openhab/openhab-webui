// This file is auto-generated by @hey-api/openapi-ts

import { buildClientParams, type Client, type Options as Options2, type TDataShape, urlSearchParamsBodySerializer } from './client';
import { client } from './client.gen';
import type { AddMemberToGroupItemErrors, AddMemberToGroupItemResponses, AddMetadataToItemErrors, AddMetadataToItemResponses, AddOrUpdateItemInRegistryErrors, AddOrUpdateItemInRegistryResponses, AddOrUpdateItemsInRegistryErrors, AddOrUpdateItemsInRegistryResponses, AddTagToItemErrors, AddTagToItemResponses, AddUiComponentToNamespaceResponses, ApproveInboxItemByIdErrors, ApproveInboxItemByIdResponses, CreateErrors, CreateFileFormatForItemsErrors, CreateFileFormatForItemsResponses, CreateFileFormatForThingsErrors, CreateFileFormatForThingsResponses, CreateResponses, CreateRuleErrors, CreateRuleResponses, CreateSemanticTagErrors, CreateSemanticTagResponses, CreateSitemapEventSubscriptionErrors, CreateSitemapEventSubscriptionResponses, CreateThingInRegistryErrors, CreateThingInRegistryResponses, DeleteItemFromPersistenceServiceErrors, DeleteItemFromPersistenceServiceResponses, DeletePersistenceServiceConfigurationErrors, DeletePersistenceServiceConfigurationResponses, DeleteRuleErrors, DeleteRuleResponses, DeleteServiceConfigErrors, DeleteServiceConfigResponses, DeleteSessionErrors, DeleteSessionResponses, DeleteTransformationErrors, DeleteTransformationResponses, EnableRuleErrors, EnableRuleResponses, EnableThingErrors, EnableThingResponses, EnrichedSemanticTag, ExecuteThingActionErrors, ExecuteThingActionResponses, FileFormat, FlagInboxItemAsIgnoredResponses, GetAddonByIdErrors, GetAddonByIdResponses, GetAddonConfigurationErrors, GetAddonConfigurationResponses, GetAddonsErrors, GetAddonServicesErrors, GetAddonServicesResponses, GetAddonsResponses, GetAddonTypesResponses, GetApiTokensErrors, GetApiTokensResponses, GetAudioDefaultSinkErrors, GetAudioDefaultSinkResponses, GetAudioDefaultSourceErrors, GetAudioDefaultSourceResponses, GetAudioSinksResponses, GetAudioSourcesResponses, GetAvailableActionsForThingErrors, GetAvailableActionsForThingResponses, GetAvailableFirmwaresForThingResponses, GetBindingsWithDiscoverySupportResponses, GetChannelTypeByUidErrors, GetChannelTypeByUidResponses, GetChannelTypesResponses, GetConfigDescriptionByUriErrors, GetConfigDescriptionByUriResponses, GetConfigDescriptionsResponses, GetDefaultVoiceErrors, GetDefaultVoiceResponses, GetDiscoveredInboxItemsResponses, GetDiscoveryServicesInfoErrors, GetDiscoveryServicesInfoResponses, GetEventsErrors, GetEventsResponses, GetIconSetsResponses, GetItemByNameErrors, GetItemByNameResponses, GetItemDataFromPersistenceServiceErrors, GetItemDataFromPersistenceServiceResponses, GetItemLinkErrors, GetItemLinkResponses, GetItemLinksResponses, GetItemNamespacesErrors, GetItemNamespacesResponses, GetItemsForPersistenceServiceResponses, GetItemsResponses, GetItemState1Errors, GetItemState1Responses, GetLinkableItemTypesByChannelTypeUidErrors, GetLinkableItemTypesByChannelTypeUidResponses, GetLogger1Responses, GetLoggerResponses, GetModuleTypeByIdErrors, GetModuleTypeByIdResponses, GetModuleTypesResponses, GetOAuthTokenErrors, GetOAuthTokenResponses, GetOrphanLinksResponses, GetPersistenceHealthResponses, GetPersistenceServiceConfigurationErrors, GetPersistenceServiceConfigurationResponses, GetPersistenceServicesResponses, GetPersistenceServiceStrategySuggestionsErrors, GetPersistenceServiceStrategySuggestionsResponses, GetProfileTypesResponses, GetRegisteredUiComponentsInNamespaceResponses, GetRootResponses, GetRuleActionsErrors, GetRuleActionsResponses, GetRuleByIdErrors, GetRuleByIdResponses, GetRuleConditionsErrors, GetRuleConditionsResponses, GetRuleConfigurationErrors, GetRuleConfigurationResponses, GetRuleModuleByIdErrors, GetRuleModuleByIdResponses, GetRuleModuleConfigErrors, GetRuleModuleConfigParameterErrors, GetRuleModuleConfigParameterResponses, GetRuleModuleConfigResponses, GetRulesResponses, GetRuleTriggersErrors, GetRuleTriggersResponses, GetScheduleRuleSimulationsErrors, GetScheduleRuleSimulationsResponses, GetSemanticItemErrors, GetSemanticItemResponses, GetSemanticsHealthErrors, GetSemanticsHealthResponses, GetSemanticTagAndSubTagsErrors, GetSemanticTagAndSubTagsResponses, GetSemanticTagsResponses, GetServiceConfigErrors, GetServiceConfigResponses, GetServiceContextResponses, GetServicesByIdErrors, GetServicesByIdResponses, GetServicesResponses, GetSessionsForCurrentUserErrors, GetSessionsForCurrentUserResponses, GetSitemapByNameResponses, GetSitemapEvents1Errors, GetSitemapEvents1Responses, GetSitemapEventsErrors, GetSitemapEventsResponses, GetSitemapsResponses, GetSuggestedAddonsResponses, GetSystemInformationResponses, GetTemplateByIdErrors, GetTemplateByIdResponses, GetTemplatesResponses, GetThingByIdErrors, GetThingByIdResponses, GetThingConfigStatusErrors, GetThingConfigStatusResponses, GetThingFirmwareStatusResponses, GetThingsResponses, GetThingStatusErrors, GetThingStatusResponses, GetThingTypeByIdErrors, GetThingTypeByIdResponses, GetThingTypesResponses, GetTransformationErrors, GetTransformationResponses, GetTransformationServicesResponses, GetTransformationsResponses, GetUiComponentInNamespaceErrors, GetUiComponentInNamespaceResponses, GetUiTilesResponses, GetUoMInformationResponses, GetUuidResponses, GetVoiceInterpreterByUidErrors, GetVoiceInterpreterByUidResponses, GetVoiceInterpretersResponses, GetVoicesResponses, GroupItem, InitNewStateTackerResponses, InstallAddonByIdErrors, InstallAddonByIdResponses, InstallAddonFromUrlErrors, InstallAddonFromUrlResponses, InterpretTextByDefaultInterpreterErrors, InterpretTextByDefaultInterpreterResponses, InterpretTextErrors, InterpretTextResponses, ItemChannelLink, LinkItemToChannelErrors, LinkItemToChannelResponses, ListenAndAnswerErrors, ListenAndAnswerResponses, LoggerInfo, Metadata, ParseErrors, ParseResponses, PersistenceServiceConfiguration, PollDataForPageErrors, PollDataForPageResponses, PollDataForSitemapErrors, PollDataForSitemapResponses, PurgeDatabase1Responses, PurgeDatabaseResponses, PutLoggerErrors, PutLoggerResponses, PutPersistenceServiceConfigurationErrors, PutPersistenceServiceConfigurationResponses, PutTransformationErrors, PutTransformationResponses, RegenerateRuleErrors, RegenerateRuleResponses, RemoveAllLinksForObjectResponses, RemoveApiTokenErrors, RemoveApiTokenResponses, RemoveIgnoreFlagOnInboxItemResponses, RemoveItemFromInboxErrors, RemoveItemFromInboxResponses, RemoveItemFromRegistryErrors, RemoveItemFromRegistryResponses, RemoveLoggerResponses, RemoveMemberFromGroupItemErrors, RemoveMemberFromGroupItemResponses, RemoveMetadataFromItemErrors, RemoveMetadataFromItemResponses, RemoveSemanticTagErrors, RemoveSemanticTagResponses, RemoveTagFromItemErrors, RemoveTagFromItemResponses, RemoveThingByIdErrors, RemoveThingByIdResponses, RemoveUiComponentFromNamespaceErrors, RemoveUiComponentFromNamespaceResponses, RootUiComponent, Rule, RunRuleNow1Errors, RunRuleNow1Responses, ScanErrors, ScanResponses, SendItemCommandErrors, SendItemCommandResponses, SetRuleModuleConfigParameterErrors, SetRuleModuleConfigParameterResponses, StartDialogErrors, StartDialogResponses, StopDialogErrors, StopDialogResponses, StoreItemDataInPersistenceServiceErrors, StoreItemDataInPersistenceServiceResponses, TextToSpeechResponses, Thing, Transformation, UninstallAddonErrors, UninstallAddonResponses, UnlinkItemFromChannelErrors, UnlinkItemFromChannelResponses, UpdateAddonConfigurationErrors, UpdateAddonConfigurationResponses, UpdateItemListForStateUpdatesErrors, UpdateItemListForStateUpdatesResponses, UpdateItemStateErrors, UpdateItemStateResponses, UpdateRuleConfigurationErrors, UpdateRuleConfigurationResponses, UpdateRuleErrors, UpdateRuleResponses, UpdateSemanticTagErrors, UpdateSemanticTagResponses, UpdateServiceConfigErrors, UpdateServiceConfigResponses, UpdateThingConfigErrors, UpdateThingConfigResponses, UpdateThingErrors, UpdateThingFirmwareErrors, UpdateThingFirmwareResponses, UpdateThingResponses, UpdateUiComponentInNamespaceErrors, UpdateUiComponentInNamespaceResponses } from './types.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = Options2<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Get all available module types.
 */
export const getModuleTypes = <ThrowOnError extends boolean = false>(parameters?: {
    'Accept-Language'?: string;
    tags?: string;
    type?: string;
    asMap?: boolean;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'headers', key: 'Accept-Language' },
                { in: 'query', key: 'tags' },
                { in: 'query', key: 'type' },
                { in: 'query', key: 'asMap' }
            ] }]);
    return (options?.client ?? client).get<GetModuleTypesResponses, unknown, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/module-types',
        ...options,
        ...params
    });
};

/**
 * Gets a module type corresponding to the given UID.
 */
export const getModuleTypeById = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    moduleTypeUID: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }, { in: 'path', key: 'moduleTypeUID' }] }]);
    return (options?.client ?? client).get<GetModuleTypeByIdResponses, GetModuleTypeByIdErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/module-types/{moduleTypeUID}',
        ...options,
        ...params
    });
};

/**
 * Get available rules, optionally filtered by tags and/or prefix.
 */
export const getRules = <ThrowOnError extends boolean = false>(parameters?: {
    prefix?: string;
    tags?: Array<string>;
    summary?: boolean;
    staticDataOnly?: boolean;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'query', key: 'prefix' },
                { in: 'query', key: 'tags' },
                { in: 'query', key: 'summary' },
                { in: 'query', key: 'staticDataOnly' }
            ] }]);
    return (options?.client ?? client).get<GetRulesResponses, unknown, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/rules',
        ...options,
        ...params
    });
};

/**
 * Creates a rule.
 */
export const createRule = <ThrowOnError extends boolean = false>(parameters: {
    rule: Rule;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ key: 'rule', map: 'body' }] }]);
    return (options?.client ?? client).post<CreateRuleResponses, CreateRuleErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/rules',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Sets the rule enabled status.
 */
export const enableRule = <ThrowOnError extends boolean = false>(parameters: {
    ruleUID: string;
    body: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'ruleUID' }, { in: 'body' }] }]);
    return (options?.client ?? client).post<EnableRuleResponses, EnableRuleErrors, ThrowOnError, 'data'>({
        bodySerializer: null,
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/rules/{ruleUID}/enable',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'text/plain',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Gets the rule actions.
 */
export const getRuleActions = <ThrowOnError extends boolean = false>(parameters: {
    ruleUID: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'ruleUID' }] }]);
    return (options?.client ?? client).get<GetRuleActionsResponses, GetRuleActionsErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/rules/{ruleUID}/actions',
        ...options,
        ...params
    });
};

/**
 * Removes an existing rule corresponding to the given UID.
 */
export const deleteRule = <ThrowOnError extends boolean = false>(parameters: {
    ruleUID: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'ruleUID' }] }]);
    return (options?.client ?? client).delete<DeleteRuleResponses, DeleteRuleErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/rules/{ruleUID}',
        ...options,
        ...params
    });
};

/**
 * Gets the rule corresponding to the given UID.
 */
export const getRuleById = <ThrowOnError extends boolean = false>(parameters: {
    ruleUID: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'ruleUID' }] }]);
    return (options?.client ?? client).get<GetRuleByIdResponses, GetRuleByIdErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/rules/{ruleUID}',
        ...options,
        ...params
    });
};

/**
 * Updates an existing rule corresponding to the given UID.
 */
export const updateRule = <ThrowOnError extends boolean = false>(parameters: {
    ruleUID: string;
    rule: Rule;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'ruleUID' }, { key: 'rule', map: 'body' }] }]);
    return (options?.client ?? client).put<UpdateRuleResponses, UpdateRuleErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/rules/{ruleUID}',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Gets the rule conditions.
 */
export const getRuleConditions = <ThrowOnError extends boolean = false>(parameters: {
    ruleUID: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'ruleUID' }] }]);
    return (options?.client ?? client).get<GetRuleConditionsResponses, GetRuleConditionsErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/rules/{ruleUID}/conditions',
        ...options,
        ...params
    });
};

/**
 * Gets the rule configuration values.
 */
export const getRuleConfiguration = <ThrowOnError extends boolean = false>(parameters: {
    ruleUID: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'ruleUID' }] }]);
    return (options?.client ?? client).get<GetRuleConfigurationResponses, GetRuleConfigurationErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/rules/{ruleUID}/config',
        ...options,
        ...params
    });
};

/**
 * Sets the rule configuration values.
 */
export const updateRuleConfiguration = <ThrowOnError extends boolean = false>(parameters: {
    ruleUID: string;
    body?: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'ruleUID' }, { in: 'body' }] }]);
    return (options?.client ?? client).put<UpdateRuleConfigurationResponses, UpdateRuleConfigurationErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/rules/{ruleUID}/config',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Gets the rule's module corresponding to the given Category and ID.
 */
export const getRuleModuleById = <ThrowOnError extends boolean = false>(parameters: {
    ruleUID: string;
    moduleCategory: string;
    id: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'path', key: 'ruleUID' },
                { in: 'path', key: 'moduleCategory' },
                { in: 'path', key: 'id' }
            ] }]);
    return (options?.client ?? client).get<GetRuleModuleByIdResponses, GetRuleModuleByIdErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/rules/{ruleUID}/{moduleCategory}/{id}',
        ...options,
        ...params
    });
};

/**
 * Gets the module's configuration.
 */
export const getRuleModuleConfig = <ThrowOnError extends boolean = false>(parameters: {
    ruleUID: string;
    moduleCategory: string;
    id: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'path', key: 'ruleUID' },
                { in: 'path', key: 'moduleCategory' },
                { in: 'path', key: 'id' }
            ] }]);
    return (options?.client ?? client).get<GetRuleModuleConfigResponses, GetRuleModuleConfigErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/rules/{ruleUID}/{moduleCategory}/{id}/config',
        ...options,
        ...params
    });
};

/**
 * Gets the module's configuration parameter.
 */
export const getRuleModuleConfigParameter = <ThrowOnError extends boolean = false>(parameters: {
    ruleUID: string;
    moduleCategory: string;
    id: string;
    param: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'path', key: 'ruleUID' },
                { in: 'path', key: 'moduleCategory' },
                { in: 'path', key: 'id' },
                { in: 'path', key: 'param' }
            ] }]);
    return (options?.client ?? client).get<GetRuleModuleConfigParameterResponses, GetRuleModuleConfigParameterErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/rules/{ruleUID}/{moduleCategory}/{id}/config/{param}',
        ...options,
        ...params
    });
};

/**
 * Sets the module's configuration parameter value.
 */
export const setRuleModuleConfigParameter = <ThrowOnError extends boolean = false>(parameters: {
    ruleUID: string;
    moduleCategory: string;
    id: string;
    param: string;
    body: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'path', key: 'ruleUID' },
                { in: 'path', key: 'moduleCategory' },
                { in: 'path', key: 'id' },
                { in: 'path', key: 'param' },
                { in: 'body' }
            ] }]);
    return (options?.client ?? client).put<SetRuleModuleConfigParameterResponses, SetRuleModuleConfigParameterErrors, ThrowOnError, 'data'>({
        bodySerializer: null,
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/rules/{ruleUID}/{moduleCategory}/{id}/config/{param}',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'text/plain',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Gets the rule triggers.
 */
export const getRuleTriggers = <ThrowOnError extends boolean = false>(parameters: {
    ruleUID: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'ruleUID' }] }]);
    return (options?.client ?? client).get<GetRuleTriggersResponses, GetRuleTriggersErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/rules/{ruleUID}/triggers',
        ...options,
        ...params
    });
};

/**
 * Regenerates the rule from its template.
 */
export const regenerateRule = <ThrowOnError extends boolean = false>(parameters: {
    ruleUID: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'ruleUID' }] }]);
    return (options?.client ?? client).post<RegenerateRuleResponses, RegenerateRuleErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/rules/{ruleUID}/regenerate',
        ...options,
        ...params
    });
};

/**
 * Executes actions of the rule.
 */
export const runRuleNow1 = <ThrowOnError extends boolean = false>(parameters: {
    ruleUID: string;
    body?: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'ruleUID' }, { in: 'body' }] }]);
    return (options?.client ?? client).post<RunRuleNow1Responses, RunRuleNow1Errors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/rules/{ruleUID}/runnow',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Simulates the executions of rules filtered by tag 'Schedule' within the given times.
 */
export const getScheduleRuleSimulations = <ThrowOnError extends boolean = false>(parameters?: {
    from?: string;
    until?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'query', key: 'from' }, { in: 'query', key: 'until' }] }]);
    return (options?.client ?? client).get<GetScheduleRuleSimulationsResponses, GetScheduleRuleSimulationsErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/rules/schedule/simulations',
        ...options,
        ...params
    });
};

/**
 * Get all available templates.
 */
export const getTemplates = <ThrowOnError extends boolean = false>(parameters?: {
    'Accept-Language'?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }] }]);
    return (options?.client ?? client).get<GetTemplatesResponses, unknown, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/templates',
        ...options,
        ...params
    });
};

/**
 * Gets a template corresponding to the given UID.
 */
export const getTemplateById = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    templateUID: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }, { in: 'path', key: 'templateUID' }] }]);
    return (options?.client ?? client).get<GetTemplateByIdResponses, GetTemplateByIdErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/templates/{templateUID}',
        ...options,
        ...params
    });
};

/**
 * Executes a thing action.
 */
export const executeThingAction = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    thingUID: string;
    actionUid: string;
    body?: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'headers', key: 'Accept-Language' },
                { in: 'path', key: 'thingUID' },
                { in: 'path', key: 'actionUid' },
                { in: 'body' }
            ] }]);
    return (options?.client ?? client).post<ExecuteThingActionResponses, ExecuteThingActionErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/actions/{thingUID}/{actionUid}',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Get all available actions for provided thing UID
 */
export const getAvailableActionsForThing = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    thingUID: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }, { in: 'path', key: 'thingUID' }] }]);
    return (options?.client ?? client).get<GetAvailableActionsForThingResponses, GetAvailableActionsForThingErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/actions/{thingUID}',
        ...options,
        ...params
    });
};

/**
 * A unified unique id.
 */
export const getUuid = <ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) => (options?.client ?? client).get<GetUuidResponses, unknown, ThrowOnError, 'data'>({
    responseStyle: 'data',
    url: '/uuid',
    ...options
});

/**
 * Get the default sink if defined or the first available sink.
 */
export const getAudioDefaultSink = <ThrowOnError extends boolean = false>(parameters?: {
    'Accept-Language'?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }] }]);
    return (options?.client ?? client).get<GetAudioDefaultSinkResponses, GetAudioDefaultSinkErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/audio/defaultsink',
        ...options,
        ...params
    });
};

/**
 * Get the default source if defined or the first available source.
 */
export const getAudioDefaultSource = <ThrowOnError extends boolean = false>(parameters?: {
    'Accept-Language'?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }] }]);
    return (options?.client ?? client).get<GetAudioDefaultSourceResponses, GetAudioDefaultSourceErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/audio/defaultsource',
        ...options,
        ...params
    });
};

/**
 * Get the list of all sinks.
 */
export const getAudioSinks = <ThrowOnError extends boolean = false>(parameters?: {
    'Accept-Language'?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }] }]);
    return (options?.client ?? client).get<GetAudioSinksResponses, unknown, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/audio/sinks',
        ...options,
        ...params
    });
};

/**
 * Get the list of all sources.
 */
export const getAudioSources = <ThrowOnError extends boolean = false>(parameters?: {
    'Accept-Language'?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }] }]);
    return (options?.client ?? client).get<GetAudioSourcesResponses, unknown, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/audio/sources',
        ...options,
        ...params
    });
};

/**
 * Delete the session associated with a refresh token.
 */
export const deleteSession = <ThrowOnError extends boolean = false>(parameters?: {
    refresh_token?: string;
    id?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'body', key: 'refresh_token' }, { in: 'body', key: 'id' }] }]);
    return (options?.client ?? client).post<DeleteSessionResponses, DeleteSessionErrors, ThrowOnError, 'data'>({
        ...urlSearchParamsBodySerializer,
        responseStyle: 'data',
        url: '/auth/logout',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * List the API tokens associated to the authenticated user.
 */
export const getApiTokens = <ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) => (options?.client ?? client).get<GetApiTokensResponses, GetApiTokensErrors, ThrowOnError, 'data'>({
    responseStyle: 'data',
    url: '/auth/apitokens',
    ...options
});

/**
 * List the sessions associated to the authenticated user.
 */
export const getSessionsForCurrentUser = <ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) => (options?.client ?? client).get<GetSessionsForCurrentUserResponses, GetSessionsForCurrentUserErrors, ThrowOnError, 'data'>({
    responseStyle: 'data',
    url: '/auth/sessions',
    ...options
});

/**
 * Get access and refresh tokens.
 */
export const getOAuthToken = <ThrowOnError extends boolean = false>(parameters?: {
    useCookie?: boolean;
    grant_type?: string;
    code?: string;
    redirect_uri?: string;
    client_id?: string;
    refresh_token?: string;
    code_verifier?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'query', key: 'useCookie' },
                { in: 'body', key: 'grant_type' },
                { in: 'body', key: 'code' },
                { in: 'body', key: 'redirect_uri' },
                { in: 'body', key: 'client_id' },
                { in: 'body', key: 'refresh_token' },
                { in: 'body', key: 'code_verifier' }
            ] }]);
    return (options?.client ?? client).post<GetOAuthTokenResponses, GetOAuthTokenErrors, ThrowOnError, 'data'>({
        ...urlSearchParamsBodySerializer,
        responseStyle: 'data',
        url: '/auth/token',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Revoke a specified API token associated to the authenticated user.
 */
export const removeApiToken = <ThrowOnError extends boolean = false>(parameters: {
    name: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'name' }] }]);
    return (options?.client ?? client).delete<RemoveApiTokenResponses, RemoveApiTokenErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/auth/apitokens/{name}',
        ...options,
        ...params
    });
};

/**
 * Get all add-ons.
 */
export const getAddons = <ThrowOnError extends boolean = false>(parameters?: {
    'Accept-Language'?: string;
    serviceId?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }, { in: 'query', key: 'serviceId' }] }]);
    return (options?.client ?? client).get<GetAddonsResponses, GetAddonsErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/addons',
        ...options,
        ...params
    });
};

/**
 * Get add-on with given ID.
 */
export const getAddonById = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    addonId: string;
    serviceId?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'headers', key: 'Accept-Language' },
                { in: 'path', key: 'addonId' },
                { in: 'query', key: 'serviceId' }
            ] }]);
    return (options?.client ?? client).get<GetAddonByIdResponses, GetAddonByIdErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/addons/{addonId}',
        ...options,
        ...params
    });
};

/**
 * Get add-on configuration for given add-on ID.
 */
export const getAddonConfiguration = <ThrowOnError extends boolean = false>(parameters: {
    addonId: string;
    serviceId?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'addonId' }, { in: 'query', key: 'serviceId' }] }]);
    return (options?.client ?? client).get<GetAddonConfigurationResponses, GetAddonConfigurationErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/addons/{addonId}/config',
        ...options,
        ...params
    });
};

/**
 * Updates an add-on configuration for given ID and returns the old configuration.
 */
export const updateAddonConfiguration = <ThrowOnError extends boolean = false>(parameters: {
    addonId: string;
    serviceId?: string;
    body?: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'path', key: 'addonId' },
                { in: 'query', key: 'serviceId' },
                { in: 'body' }
            ] }]);
    return (options?.client ?? client).put<UpdateAddonConfigurationResponses, UpdateAddonConfigurationErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/addons/{addonId}/config',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Get all add-on types.
 */
export const getAddonTypes = <ThrowOnError extends boolean = false>(parameters?: {
    'Accept-Language'?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }] }]);
    return (options?.client ?? client).get<GetAddonTypesResponses, unknown, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/addons/services',
        ...options,
        ...params
    });
};

/**
 * Get suggested add-ons to be installed.
 */
export const getSuggestedAddons = <ThrowOnError extends boolean = false>(parameters?: {
    'Accept-Language'?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }] }]);
    return (options?.client ?? client).get<GetSuggestedAddonsResponses, unknown, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/addons/suggestions',
        ...options,
        ...params
    });
};

/**
 * Get add-on services.
 */
export const getAddonServices = <ThrowOnError extends boolean = false>(parameters?: {
    'Accept-Language'?: string;
    serviceId?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }, { in: 'query', key: 'serviceId' }] }]);
    return (options?.client ?? client).get<GetAddonServicesResponses, GetAddonServicesErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/addons/types',
        ...options,
        ...params
    });
};

/**
 * Installs the add-on with the given ID.
 */
export const installAddonById = <ThrowOnError extends boolean = false>(parameters: {
    addonId: string;
    serviceId?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'addonId' }, { in: 'query', key: 'serviceId' }] }]);
    return (options?.client ?? client).post<InstallAddonByIdResponses, InstallAddonByIdErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/addons/{addonId}/install',
        ...options,
        ...params
    });
};

/**
 * Installs the add-on from the given URL.
 */
export const installAddonFromUrl = <ThrowOnError extends boolean = false>(parameters: {
    url: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'url' }] }]);
    return (options?.client ?? client).post<InstallAddonFromUrlResponses, InstallAddonFromUrlErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/addons/url/{url}/install',
        ...options,
        ...params
    });
};

/**
 * Uninstalls the add-on with the given ID.
 */
export const uninstallAddon = <ThrowOnError extends boolean = false>(parameters: {
    addonId: string;
    serviceId?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'addonId' }, { in: 'query', key: 'serviceId' }] }]);
    return (options?.client ?? client).post<UninstallAddonResponses, UninstallAddonErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/addons/{addonId}/uninstall',
        ...options,
        ...params
    });
};

/**
 * Gets all available channel types.
 */
export const getChannelTypes = <ThrowOnError extends boolean = false>(parameters?: {
    'Accept-Language'?: string;
    prefixes?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }, { in: 'query', key: 'prefixes' }] }]);
    return (options?.client ?? client).get<GetChannelTypesResponses, unknown, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/channel-types',
        ...options,
        ...params
    });
};

/**
 * Gets channel type by UID.
 */
export const getChannelTypeByUid = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    channelTypeUID: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }, { in: 'path', key: 'channelTypeUID' }] }]);
    return (options?.client ?? client).get<GetChannelTypeByUidResponses, GetChannelTypeByUidErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/channel-types/{channelTypeUID}',
        ...options,
        ...params
    });
};

/**
 * Gets the item types the given trigger channel type UID can be linked to.
 */
export const getLinkableItemTypesByChannelTypeUid = <ThrowOnError extends boolean = false>(parameters: {
    channelTypeUID: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'channelTypeUID' }] }]);
    return (options?.client ?? client).get<GetLinkableItemTypesByChannelTypeUidResponses, GetLinkableItemTypesByChannelTypeUidErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/channel-types/{channelTypeUID}/linkableItemTypes',
        ...options,
        ...params
    });
};

/**
 * Gets all available config descriptions.
 */
export const getConfigDescriptions = <ThrowOnError extends boolean = false>(parameters?: {
    'Accept-Language'?: string;
    scheme?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }, { in: 'query', key: 'scheme' }] }]);
    return (options?.client ?? client).get<GetConfigDescriptionsResponses, unknown, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/config-descriptions',
        ...options,
        ...params
    });
};

/**
 * Gets a config description by URI.
 */
export const getConfigDescriptionByUri = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    uri: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }, { in: 'path', key: 'uri' }] }]);
    return (options?.client ?? client).get<GetConfigDescriptionByUriResponses, GetConfigDescriptionByUriErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/config-descriptions/{uri}',
        ...options,
        ...params
    });
};

/**
 * Gets all bindings that support discovery.
 */
export const getBindingsWithDiscoverySupport = <ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) => (options?.client ?? client).get<GetBindingsWithDiscoverySupportResponses, unknown, ThrowOnError, 'data'>({
    responseStyle: 'data',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/discovery',
    ...options
});

/**
 * Gets information about the discovery services for a binding.
 */
export const getDiscoveryServicesInfo = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    bindingId: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }, { in: 'path', key: 'bindingId' }] }]);
    return (options?.client ?? client).get<GetDiscoveryServicesInfoResponses, GetDiscoveryServicesInfoErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/discovery/bindings/{bindingId}/info',
        ...options,
        ...params
    });
};

/**
 * Starts asynchronous discovery process for a binding and returns the timeout in seconds of the discovery operation.
 */
export const scan = <ThrowOnError extends boolean = false>(parameters: {
    bindingId: string;
    input?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'bindingId' }, { in: 'query', key: 'input' }] }]);
    return (options?.client ?? client).post<ScanResponses, ScanErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/discovery/bindings/{bindingId}/scan',
        ...options,
        ...params
    });
};

/**
 * Approves the discovery result by adding the thing to the registry.
 */
export const approveInboxItemById = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    thingUID: string;
    newThingId?: string;
    body?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'headers', key: 'Accept-Language' },
                { in: 'path', key: 'thingUID' },
                { in: 'query', key: 'newThingId' },
                { in: 'body' }
            ] }]);
    return (options?.client ?? client).post<ApproveInboxItemByIdResponses, ApproveInboxItemByIdErrors, ThrowOnError, 'data'>({
        bodySerializer: null,
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/inbox/{thingUID}/approve',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'text/plain',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Removes the discovery result from the inbox.
 */
export const removeItemFromInbox = <ThrowOnError extends boolean = false>(parameters: {
    thingUID: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'thingUID' }] }]);
    return (options?.client ?? client).delete<RemoveItemFromInboxResponses, RemoveItemFromInboxErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/inbox/{thingUID}',
        ...options,
        ...params
    });
};

/**
 * Get all discovered things.
 */
export const getDiscoveredInboxItems = <ThrowOnError extends boolean = false>(parameters?: {
    includeIgnored?: boolean;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'query', key: 'includeIgnored' }] }]);
    return (options?.client ?? client).get<GetDiscoveredInboxItemsResponses, unknown, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/inbox',
        ...options,
        ...params
    });
};

/**
 * Flags a discovery result as ignored for further processing.
 */
export const flagInboxItemAsIgnored = <ThrowOnError extends boolean = false>(parameters: {
    thingUID: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'thingUID' }] }]);
    return (options?.client ?? client).post<FlagInboxItemAsIgnoredResponses, unknown, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/inbox/{thingUID}/ignore',
        ...options,
        ...params
    });
};

/**
 * Removes ignore flag from a discovery result.
 */
export const removeIgnoreFlagOnInboxItem = <ThrowOnError extends boolean = false>(parameters: {
    thingUID: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'thingUID' }] }]);
    return (options?.client ?? client).post<RemoveIgnoreFlagOnInboxItemResponses, unknown, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/inbox/{thingUID}/unignore',
        ...options,
        ...params
    });
};

/**
 * Create file format.
 */
export const create = <ThrowOnError extends boolean = false>(parameters: {
    hideDefaultParameters?: boolean;
    hideDefaultChannels?: boolean;
    hideChannelLinksAndMetadata?: boolean;
    fileFormat: FileFormat;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'query', key: 'hideDefaultParameters' },
                { in: 'query', key: 'hideDefaultChannels' },
                { in: 'query', key: 'hideChannelLinksAndMetadata' },
                { key: 'fileFormat', map: 'body' }
            ] }]);
    return (options?.client ?? client).post<CreateResponses, CreateErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/file-format/create',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Create file format for a list of items in registry.
 */
export const createFileFormatForItems = <ThrowOnError extends boolean = false>(parameters?: {
    hideDefaultParameters?: boolean;
    body?: Array<string>;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'query', key: 'hideDefaultParameters' }, { in: 'body' }] }]);
    return (options?.client ?? client).post<CreateFileFormatForItemsResponses, CreateFileFormatForItemsErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/file-format/items',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Create file format for a list of things in things or discovery registry.
 */
export const createFileFormatForThings = <ThrowOnError extends boolean = false>(parameters?: {
    hideDefaultParameters?: boolean;
    body?: Array<string>;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'query', key: 'hideDefaultParameters' }, { in: 'body' }] }]);
    return (options?.client ?? client).post<CreateFileFormatForThingsResponses, CreateFileFormatForThingsErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/file-format/things',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Parse file format.
 */
export const parse = <ThrowOnError extends boolean = false>(parameters: {
    body: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'body' }] }]);
    return (options?.client ?? client).post<ParseResponses, ParseErrors, ThrowOnError, 'data'>({
        bodySerializer: null,
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/file-format/parse',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'text/vnd.openhab.dsl.thing',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Removes an existing member from a group item.
 */
export const removeMemberFromGroupItem = <ThrowOnError extends boolean = false>(parameters: {
    itemName: string;
    memberItemName: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'itemName' }, { in: 'path', key: 'memberItemName' }] }]);
    return (options?.client ?? client).delete<RemoveMemberFromGroupItemResponses, RemoveMemberFromGroupItemErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/items/{itemName}/members/{memberItemName}',
        ...options,
        ...params
    });
};

/**
 * Adds a new member to a group item.
 */
export const addMemberToGroupItem = <ThrowOnError extends boolean = false>(parameters: {
    itemName: string;
    memberItemName: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'itemName' }, { in: 'path', key: 'memberItemName' }] }]);
    return (options?.client ?? client).put<AddMemberToGroupItemResponses, AddMemberToGroupItemErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/items/{itemName}/members/{memberItemName}',
        ...options,
        ...params
    });
};

/**
 * Removes metadata from an item.
 */
export const removeMetadataFromItem = <ThrowOnError extends boolean = false>(parameters: {
    itemname: string;
    namespace: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'itemname' }, { in: 'path', key: 'namespace' }] }]);
    return (options?.client ?? client).delete<RemoveMetadataFromItemResponses, RemoveMetadataFromItemErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/items/{itemname}/metadata/{namespace}',
        ...options,
        ...params
    });
};

/**
 * Adds metadata to an item.
 */
export const addMetadataToItem = <ThrowOnError extends boolean = false>(parameters: {
    itemname: string;
    namespace: string;
    metadata: Metadata;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'path', key: 'itemname' },
                { in: 'path', key: 'namespace' },
                { key: 'metadata', map: 'body' }
            ] }]);
    return (options?.client ?? client).put<AddMetadataToItemResponses, AddMetadataToItemErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/items/{itemname}/metadata/{namespace}',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Removes a tag from an item.
 */
export const removeTagFromItem = <ThrowOnError extends boolean = false>(parameters: {
    itemname: string;
    tag: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'itemname' }, { in: 'path', key: 'tag' }] }]);
    return (options?.client ?? client).delete<RemoveTagFromItemResponses, RemoveTagFromItemErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/items/{itemname}/tags/{tag}',
        ...options,
        ...params
    });
};

/**
 * Adds a tag to an item.
 */
export const addTagToItem = <ThrowOnError extends boolean = false>(parameters: {
    itemname: string;
    tag: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'itemname' }, { in: 'path', key: 'tag' }] }]);
    return (options?.client ?? client).put<AddTagToItemResponses, AddTagToItemErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/items/{itemname}/tags/{tag}',
        ...options,
        ...params
    });
};

/**
 * Removes an item from the registry.
 */
export const removeItemFromRegistry = <ThrowOnError extends boolean = false>(parameters: {
    itemname: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'itemname' }] }]);
    return (options?.client ?? client).delete<RemoveItemFromRegistryResponses, RemoveItemFromRegistryErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/items/{itemname}',
        ...options,
        ...params
    });
};

/**
 * Gets a single item.
 */
export const getItemByName = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    itemname: string;
    metadata?: string;
    recursive?: boolean;
    parents?: boolean;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'headers', key: 'Accept-Language' },
                { in: 'path', key: 'itemname' },
                { in: 'query', key: 'metadata' },
                { in: 'query', key: 'recursive' },
                { in: 'query', key: 'parents' }
            ] }]);
    return (options?.client ?? client).get<GetItemByNameResponses, GetItemByNameErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/items/{itemname}',
        ...options,
        ...params
    });
};

/**
 * Sends a command to an item.
 */
export const sendItemCommand = <ThrowOnError extends boolean = false>(parameters: {
    'X-OpenHAB-Source'?: string;
    itemname: string;
    source?: string;
    body: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'headers', key: 'X-OpenHAB-Source' },
                { in: 'path', key: 'itemname' },
                { in: 'query', key: 'source' },
                { in: 'body' }
            ] }]);
    return (options?.client ?? client).post<SendItemCommandResponses, SendItemCommandErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/items/{itemname}',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Adds a new item to the registry or updates the existing item.
 */
export const addOrUpdateItemInRegistry = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    itemname: string;
    groupItem: GroupItem;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'headers', key: 'Accept-Language' },
                { in: 'path', key: 'itemname' },
                { key: 'groupItem', map: 'body' }
            ] }]);
    return (options?.client ?? client).put<AddOrUpdateItemInRegistryResponses, AddOrUpdateItemInRegistryErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/items/{itemname}',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Get all available items.
 */
export const getItems = <ThrowOnError extends boolean = false>(parameters?: {
    'Accept-Language'?: string;
    type?: string;
    tags?: string;
    metadata?: string;
    recursive?: boolean;
    parents?: boolean;
    fields?: string;
    staticDataOnly?: boolean;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'headers', key: 'Accept-Language' },
                { in: 'query', key: 'type' },
                { in: 'query', key: 'tags' },
                { in: 'query', key: 'metadata' },
                { in: 'query', key: 'recursive' },
                { in: 'query', key: 'parents' },
                { in: 'query', key: 'fields' },
                { in: 'query', key: 'staticDataOnly' }
            ] }]);
    return (options?.client ?? client).get<GetItemsResponses, unknown, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/items',
        ...options,
        ...params
    });
};

/**
 * Adds a list of items to the registry or updates the existing items.
 */
export const addOrUpdateItemsInRegistry = <ThrowOnError extends boolean = false>(parameters: {
    body: Array<GroupItem>;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'body' }] }]);
    return (options?.client ?? client).put<AddOrUpdateItemsInRegistryResponses, AddOrUpdateItemsInRegistryErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/items',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Gets the state of an item.
 */
export const getItemState1 = <ThrowOnError extends boolean = false>(parameters: {
    itemname: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'itemname' }] }]);
    return (options?.client ?? client).get<GetItemState1Responses, GetItemState1Errors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/items/{itemname}/state',
        ...options,
        ...params
    });
};

/**
 * Updates the state of an item.
 */
export const updateItemState = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    'X-OpenHAB-Source'?: string;
    itemname: string;
    source?: string;
    body: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'headers', key: 'Accept-Language' },
                { in: 'headers', key: 'X-OpenHAB-Source' },
                { in: 'path', key: 'itemname' },
                { in: 'query', key: 'source' },
                { in: 'body' }
            ] }]);
    return (options?.client ?? client).put<UpdateItemStateResponses, UpdateItemStateErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/items/{itemname}/state',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Gets the namespace of an item.
 */
export const getItemNamespaces = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    itemname: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }, { in: 'path', key: 'itemname' }] }]);
    return (options?.client ?? client).get<GetItemNamespacesResponses, GetItemNamespacesErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/items/{itemname}/metadata/namespaces',
        ...options,
        ...params
    });
};

/**
 * Gets the item which defines the requested semantics of an item.
 */
export const getSemanticItem = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    itemName: string;
    semanticClass: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'headers', key: 'Accept-Language' },
                { in: 'path', key: 'itemName' },
                { in: 'path', key: 'semanticClass' }
            ] }]);
    return (options?.client ?? client).get<GetSemanticItemResponses, GetSemanticItemErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/items/{itemName}/semantic/{semanticClass}',
        ...options,
        ...params
    });
};

/**
 * Gets configuration problems with item semantics.
 */
export const getSemanticsHealth = <ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) => (options?.client ?? client).get<GetSemanticsHealthResponses, GetSemanticsHealthErrors, ThrowOnError, 'data'>({
    responseStyle: 'data',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/items/semantics/health',
    ...options
});

/**
 * Remove unused/orphaned metadata.
 */
export const purgeDatabase = <ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) => (options?.client ?? client).post<PurgeDatabaseResponses, unknown, ThrowOnError, 'data'>({
    responseStyle: 'data',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/items/metadata/purge',
    ...options
});

/**
 * Gets all available links.
 */
export const getItemLinks = <ThrowOnError extends boolean = false>(parameters?: {
    channelUID?: string;
    itemName?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'query', key: 'channelUID' }, { in: 'query', key: 'itemName' }] }]);
    return (options?.client ?? client).get<GetItemLinksResponses, unknown, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/links',
        ...options,
        ...params
    });
};

/**
 * Unlinks an item from a channel.
 */
export const unlinkItemFromChannel = <ThrowOnError extends boolean = false>(parameters: {
    itemName: string;
    channelUID: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'itemName' }, { in: 'path', key: 'channelUID' }] }]);
    return (options?.client ?? client).delete<UnlinkItemFromChannelResponses, UnlinkItemFromChannelErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/links/{itemName}/{channelUID}',
        ...options,
        ...params
    });
};

/**
 * Retrieves an individual link.
 */
export const getItemLink = <ThrowOnError extends boolean = false>(parameters: {
    itemName: string;
    channelUID: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'itemName' }, { in: 'path', key: 'channelUID' }] }]);
    return (options?.client ?? client).get<GetItemLinkResponses, GetItemLinkErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/links/{itemName}/{channelUID}',
        ...options,
        ...params
    });
};

/**
 * Links an item to a channel.
 */
export const linkItemToChannel = <ThrowOnError extends boolean = false>(parameters: {
    itemName: string;
    channelUID: string;
    itemChannelLink?: ItemChannelLink;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'path', key: 'itemName' },
                { in: 'path', key: 'channelUID' },
                { key: 'itemChannelLink', map: 'body' }
            ] }]);
    return (options?.client ?? client).put<LinkItemToChannelResponses, LinkItemToChannelErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/links/{itemName}/{channelUID}',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Get orphan links between items and broken/non-existent thing channels
 */
export const getOrphanLinks = <ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) => (options?.client ?? client).get<GetOrphanLinksResponses, unknown, ThrowOnError, 'data'>({
    responseStyle: 'data',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/links/orphans',
    ...options
});

/**
 * Remove unused/orphaned links.
 */
export const purgeDatabase1 = <ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) => (options?.client ?? client).post<PurgeDatabase1Responses, unknown, ThrowOnError, 'data'>({
    responseStyle: 'data',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/links/purge',
    ...options
});

/**
 * Delete all links that refer to an item or thing.
 */
export const removeAllLinksForObject = <ThrowOnError extends boolean = false>(parameters: {
    object: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'object' }] }]);
    return (options?.client ?? client).delete<RemoveAllLinksForObjectResponses, unknown, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/links/{object}',
        ...options,
        ...params
    });
};

/**
 * Deletes a persistence service configuration.
 */
export const deletePersistenceServiceConfiguration = <ThrowOnError extends boolean = false>(parameters: {
    serviceId: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'serviceId' }] }]);
    return (options?.client ?? client).delete<DeletePersistenceServiceConfigurationResponses, DeletePersistenceServiceConfigurationErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/persistence/{serviceId}',
        ...options,
        ...params
    });
};

/**
 * Gets a persistence service configuration.
 */
export const getPersistenceServiceConfiguration = <ThrowOnError extends boolean = false>(parameters: {
    serviceId: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'serviceId' }] }]);
    return (options?.client ?? client).get<GetPersistenceServiceConfigurationResponses, GetPersistenceServiceConfigurationErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/persistence/{serviceId}',
        ...options,
        ...params
    });
};

/**
 * Sets a persistence service configuration.
 */
export const putPersistenceServiceConfiguration = <ThrowOnError extends boolean = false>(parameters: {
    serviceId: string;
    persistenceServiceConfiguration: PersistenceServiceConfiguration;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'serviceId' }, { key: 'persistenceServiceConfiguration', map: 'body' }] }]);
    return (options?.client ?? client).put<PutPersistenceServiceConfigurationResponses, PutPersistenceServiceConfigurationErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/persistence/{serviceId}',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Deletes item persistence data from a specific persistence service in a given time range.
 */
export const deleteItemFromPersistenceService = <ThrowOnError extends boolean = false>(parameters: {
    itemname: string;
    serviceId: string;
    starttime: string;
    endtime: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'path', key: 'itemname' },
                { in: 'query', key: 'serviceId' },
                { in: 'query', key: 'starttime' },
                { in: 'query', key: 'endtime' }
            ] }]);
    return (options?.client ?? client).delete<DeleteItemFromPersistenceServiceResponses, DeleteItemFromPersistenceServiceErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/persistence/items/{itemname}',
        ...options,
        ...params
    });
};

/**
 * Gets item persistence data from the persistence service.
 */
export const getItemDataFromPersistenceService = <ThrowOnError extends boolean = false>(parameters: {
    itemname: string;
    serviceId?: string;
    starttime?: string;
    endtime?: string;
    page?: number;
    pagelength?: number;
    boundary?: boolean;
    itemState?: boolean;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'path', key: 'itemname' },
                { in: 'query', key: 'serviceId' },
                { in: 'query', key: 'starttime' },
                { in: 'query', key: 'endtime' },
                { in: 'query', key: 'page' },
                { in: 'query', key: 'pagelength' },
                { in: 'query', key: 'boundary' },
                { in: 'query', key: 'itemState' }
            ] }]);
    return (options?.client ?? client).get<GetItemDataFromPersistenceServiceResponses, GetItemDataFromPersistenceServiceErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/persistence/items/{itemname}',
        ...options,
        ...params
    });
};

/**
 * Stores item persistence data into the persistence service.
 */
export const storeItemDataInPersistenceService = <ThrowOnError extends boolean = false>(parameters: {
    itemname: string;
    serviceId?: string;
    time: string;
    state: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'path', key: 'itemname' },
                { in: 'query', key: 'serviceId' },
                { in: 'query', key: 'time' },
                { in: 'query', key: 'state' }
            ] }]);
    return (options?.client ?? client).put<StoreItemDataInPersistenceServiceResponses, StoreItemDataInPersistenceServiceErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/persistence/items/{itemname}',
        ...options,
        ...params
    });
};

/**
 * Gets configuration problems with persistence services.
 */
export const getPersistenceHealth = <ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) => (options?.client ?? client).get<GetPersistenceHealthResponses, unknown, ThrowOnError, 'data'>({
    responseStyle: 'data',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/persistence/persistencehealth',
    ...options
});

/**
 * Gets a list of items available via a specific persistence service.
 */
export const getItemsForPersistenceService = <ThrowOnError extends boolean = false>(parameters?: {
    serviceId?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'query', key: 'serviceId' }] }]);
    return (options?.client ?? client).get<GetItemsForPersistenceServiceResponses, unknown, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/persistence/items',
        ...options,
        ...params
    });
};

/**
 * Gets a persistence service suggested strategies.
 */
export const getPersistenceServiceStrategySuggestions = <ThrowOnError extends boolean = false>(parameters?: {
    serviceId?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'query', key: 'serviceId' }] }]);
    return (options?.client ?? client).get<GetPersistenceServiceStrategySuggestionsResponses, GetPersistenceServiceStrategySuggestionsErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/persistence/strategysuggestions',
        ...options,
        ...params
    });
};

/**
 * Gets a list of persistence services.
 */
export const getPersistenceServices = <ThrowOnError extends boolean = false>(parameters?: {
    'Accept-Language'?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }] }]);
    return (options?.client ?? client).get<GetPersistenceServicesResponses, unknown, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/persistence',
        ...options,
        ...params
    });
};

/**
 * Gets all available profile types.
 */
export const getProfileTypes = <ThrowOnError extends boolean = false>(parameters?: {
    'Accept-Language'?: string;
    channelTypeUID?: string;
    itemType?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'headers', key: 'Accept-Language' },
                { in: 'query', key: 'channelTypeUID' },
                { in: 'query', key: 'itemType' }
            ] }]);
    return (options?.client ?? client).get<GetProfileTypesResponses, unknown, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/profile-types',
        ...options,
        ...params
    });
};

/**
 * Deletes a service configuration for given service ID and returns the old configuration.
 */
export const deleteServiceConfig = <ThrowOnError extends boolean = false>(parameters: {
    serviceId: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'serviceId' }] }]);
    return (options?.client ?? client).delete<DeleteServiceConfigResponses, DeleteServiceConfigErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/services/{serviceId}/config',
        ...options,
        ...params
    });
};

/**
 * Get service configuration for given service ID.
 */
export const getServiceConfig = <ThrowOnError extends boolean = false>(parameters: {
    serviceId: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'serviceId' }] }]);
    return (options?.client ?? client).get<GetServiceConfigResponses, GetServiceConfigErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/services/{serviceId}/config',
        ...options,
        ...params
    });
};

/**
 * Updates a service configuration for given service ID and returns the old configuration.
 */
export const updateServiceConfig = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    serviceId: string;
    body?: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'headers', key: 'Accept-Language' },
                { in: 'path', key: 'serviceId' },
                { in: 'body' }
            ] }]);
    return (options?.client ?? client).put<UpdateServiceConfigResponses, UpdateServiceConfigErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/services/{serviceId}/config',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Get all configurable services.
 */
export const getServices = <ThrowOnError extends boolean = false>(parameters?: {
    'Accept-Language'?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }] }]);
    return (options?.client ?? client).get<GetServicesResponses, unknown, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/services',
        ...options,
        ...params
    });
};

/**
 * Get configurable service for given service ID.
 */
export const getServicesById = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    serviceId: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }, { in: 'path', key: 'serviceId' }] }]);
    return (options?.client ?? client).get<GetServicesByIdResponses, GetServicesByIdErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/services/{serviceId}',
        ...options,
        ...params
    });
};

/**
 * Get existing multiple context service configurations for the given factory PID.
 */
export const getServiceContext = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    serviceId: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }, { in: 'path', key: 'serviceId' }] }]);
    return (options?.client ?? client).get<GetServiceContextResponses, unknown, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/services/{serviceId}/contexts',
        ...options,
        ...params
    });
};

/**
 * Get all available semantic tags.
 */
export const getSemanticTags = <ThrowOnError extends boolean = false>(parameters?: {
    'Accept-Language'?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }] }]);
    return (options?.client ?? client).get<GetSemanticTagsResponses, unknown, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/tags',
        ...options,
        ...params
    });
};

/**
 * Creates a new semantic tag and adds it to the registry.
 */
export const createSemanticTag = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    enrichedSemanticTag: EnrichedSemanticTag;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }, { key: 'enrichedSemanticTag', map: 'body' }] }]);
    return (options?.client ?? client).post<CreateSemanticTagResponses, CreateSemanticTagErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/tags',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Removes a semantic tag and its sub tags from the registry.
 */
export const removeSemanticTag = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    tagId: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }, { in: 'path', key: 'tagId' }] }]);
    return (options?.client ?? client).delete<RemoveSemanticTagResponses, RemoveSemanticTagErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/tags/{tagId}',
        ...options,
        ...params
    });
};

/**
 * Gets a semantic tag and its sub tags.
 */
export const getSemanticTagAndSubTags = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    tagId: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }, { in: 'path', key: 'tagId' }] }]);
    return (options?.client ?? client).get<GetSemanticTagAndSubTagsResponses, GetSemanticTagAndSubTagsErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/tags/{tagId}',
        ...options,
        ...params
    });
};

/**
 * Updates a semantic tag.
 */
export const updateSemanticTag = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    tagId: string;
    enrichedSemanticTag: EnrichedSemanticTag;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'headers', key: 'Accept-Language' },
                { in: 'path', key: 'tagId' },
                { key: 'enrichedSemanticTag', map: 'body' }
            ] }]);
    return (options?.client ?? client).put<UpdateSemanticTagResponses, UpdateSemanticTagErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/tags/{tagId}',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Get all available things.
 */
export const getThings = <ThrowOnError extends boolean = false>(parameters?: {
    'Accept-Language'?: string;
    summary?: boolean;
    staticDataOnly?: boolean;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'headers', key: 'Accept-Language' },
                { in: 'query', key: 'summary' },
                { in: 'query', key: 'staticDataOnly' }
            ] }]);
    return (options?.client ?? client).get<GetThingsResponses, unknown, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/things',
        ...options,
        ...params
    });
};

/**
 * Creates a new thing and adds it to the registry.
 */
export const createThingInRegistry = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    thing: Thing;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }, { key: 'thing', map: 'body' }] }]);
    return (options?.client ?? client).post<CreateThingInRegistryResponses, CreateThingInRegistryErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/things',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Removes a thing from the registry. Set 'force' to __true__ if you want the thing to be removed immediately.
 */
export const removeThingById = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    thingUID: string;
    force?: boolean;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'headers', key: 'Accept-Language' },
                { in: 'path', key: 'thingUID' },
                { in: 'query', key: 'force' }
            ] }]);
    return (options?.client ?? client).delete<RemoveThingByIdResponses, RemoveThingByIdErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/things/{thingUID}',
        ...options,
        ...params
    });
};

/**
 * Gets thing by UID.
 */
export const getThingById = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    thingUID: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }, { in: 'path', key: 'thingUID' }] }]);
    return (options?.client ?? client).get<GetThingByIdResponses, GetThingByIdErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/things/{thingUID}',
        ...options,
        ...params
    });
};

/**
 * Updates a thing.
 */
export const updateThing = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    thingUID: string;
    thing: Thing;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'headers', key: 'Accept-Language' },
                { in: 'path', key: 'thingUID' },
                { key: 'thing', map: 'body' }
            ] }]);
    return (options?.client ?? client).put<UpdateThingResponses, UpdateThingErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/things/{thingUID}',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Gets thing config status.
 */
export const getThingConfigStatus = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    thingUID: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }, { in: 'path', key: 'thingUID' }] }]);
    return (options?.client ?? client).get<GetThingConfigStatusResponses, GetThingConfigStatusErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/things/{thingUID}/config/status',
        ...options,
        ...params
    });
};

/**
 * Gets thing's firmware status.
 */
export const getThingFirmwareStatus = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    thingUID: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }, { in: 'path', key: 'thingUID' }] }]);
    return (options?.client ?? client).get<GetThingFirmwareStatusResponses, unknown, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/things/{thingUID}/firmware/status',
        ...options,
        ...params
    });
};

/**
 * Get all available firmwares for provided thing UID
 */
export const getAvailableFirmwaresForThing = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    thingUID: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }, { in: 'path', key: 'thingUID' }] }]);
    return (options?.client ?? client).get<GetAvailableFirmwaresForThingResponses, unknown, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/things/{thingUID}/firmwares',
        ...options,
        ...params
    });
};

/**
 * Gets thing status.
 */
export const getThingStatus = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    thingUID: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }, { in: 'path', key: 'thingUID' }] }]);
    return (options?.client ?? client).get<GetThingStatusResponses, GetThingStatusErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/things/{thingUID}/status',
        ...options,
        ...params
    });
};

/**
 * Sets the thing enabled status.
 */
export const enableThing = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    thingUID: string;
    body?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'headers', key: 'Accept-Language' },
                { in: 'path', key: 'thingUID' },
                { in: 'body' }
            ] }]);
    return (options?.client ?? client).put<EnableThingResponses, EnableThingErrors, ThrowOnError, 'data'>({
        bodySerializer: null,
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/things/{thingUID}/enable',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'text/plain',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Updates thing's configuration.
 */
export const updateThingConfig = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    thingUID: string;
    body?: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'headers', key: 'Accept-Language' },
                { in: 'path', key: 'thingUID' },
                { in: 'body' }
            ] }]);
    return (options?.client ?? client).put<UpdateThingConfigResponses, UpdateThingConfigErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/things/{thingUID}/config',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Update thing firmware.
 */
export const updateThingFirmware = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    thingUID: string;
    firmwareVersion: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'headers', key: 'Accept-Language' },
                { in: 'path', key: 'thingUID' },
                { in: 'path', key: 'firmwareVersion' }
            ] }]);
    return (options?.client ?? client).put<UpdateThingFirmwareResponses, UpdateThingFirmwareErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/things/{thingUID}/firmware/{firmwareVersion}',
        ...options,
        ...params
    });
};

/**
 * Gets all available thing types without config description, channels and properties.
 */
export const getThingTypes = <ThrowOnError extends boolean = false>(parameters?: {
    'Accept-Language'?: string;
    bindingId?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }, { in: 'query', key: 'bindingId' }] }]);
    return (options?.client ?? client).get<GetThingTypesResponses, unknown, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/thing-types',
        ...options,
        ...params
    });
};

/**
 * Gets thing type by UID.
 */
export const getThingTypeById = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    thingTypeUID: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }, { in: 'path', key: 'thingTypeUID' }] }]);
    return (options?.client ?? client).get<GetThingTypeByIdResponses, GetThingTypeByIdErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/thing-types/{thingTypeUID}',
        ...options,
        ...params
    });
};

/**
 * Gets information about the runtime, the API version and links to resources.
 */
export const getRoot = <ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) => (options?.client ?? client).get<GetRootResponses, unknown, ThrowOnError, 'data'>({
    responseStyle: 'data',
    url: '/',
    ...options
});

/**
 * Gets information about the system.
 */
export const getSystemInformation = <ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) => (options?.client ?? client).get<GetSystemInformationResponses, unknown, ThrowOnError, 'data'>({
    responseStyle: 'data',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/systeminfo',
    ...options
});

/**
 * Get all supported dimensions and their system units.
 */
export const getUoMInformation = <ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) => (options?.client ?? client).get<GetUoMInformationResponses, unknown, ThrowOnError, 'data'>({
    responseStyle: 'data',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/systeminfo/uom',
    ...options
});

/**
 * Creates a sitemap event subscription.
 */
export const createSitemapEventSubscription = <ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) => (options?.client ?? client).post<CreateSitemapEventSubscriptionResponses, CreateSitemapEventSubscriptionErrors, ThrowOnError, 'data'>({
    responseStyle: 'data',
    url: '/sitemaps/events/subscribe',
    ...options
});

/**
 * Polls the data for one page of a sitemap.
 */
export const pollDataForPage = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    sitemapname: string;
    pageid: string;
    subscriptionid?: string;
    includeHidden?: boolean;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'headers', key: 'Accept-Language' },
                { in: 'path', key: 'sitemapname' },
                { in: 'path', key: 'pageid' },
                { in: 'query', key: 'subscriptionid' },
                { in: 'query', key: 'includeHidden' }
            ] }]);
    return (options?.client ?? client).get<PollDataForPageResponses, PollDataForPageErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/sitemaps/{sitemapname}/{pageid}',
        ...options,
        ...params
    });
};

/**
 * Polls the data for a whole sitemap. Not recommended due to potentially high traffic.
 */
export const pollDataForSitemap = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    sitemapname: string;
    subscriptionid?: string;
    includeHidden?: boolean;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'headers', key: 'Accept-Language' },
                { in: 'path', key: 'sitemapname' },
                { in: 'query', key: 'subscriptionid' },
                { in: 'query', key: 'includeHidden' }
            ] }]);
    return (options?.client ?? client).get<PollDataForSitemapResponses, PollDataForSitemapErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/sitemaps/{sitemapname}/*',
        ...options,
        ...params
    });
};

/**
 * Get sitemap by name.
 */
export const getSitemapByName = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    sitemapname: string;
    type?: string;
    jsoncallback?: string;
    includeHidden?: boolean;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'headers', key: 'Accept-Language' },
                { in: 'path', key: 'sitemapname' },
                { in: 'query', key: 'type' },
                { in: 'query', key: 'jsoncallback' },
                { in: 'query', key: 'includeHidden' }
            ] }]);
    return (options?.client ?? client).get<GetSitemapByNameResponses, unknown, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/sitemaps/{sitemapname}',
        ...options,
        ...params
    });
};

/**
 * Get sitemap events for a whole sitemap. Not recommended due to potentially high traffic.
 */
export const getSitemapEvents = <ThrowOnError extends boolean = false>(parameters: {
    subscriptionid: string;
    sitemap?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'subscriptionid' }, { in: 'query', key: 'sitemap' }] }]);
    return (options?.client ?? client).get<GetSitemapEventsResponses, GetSitemapEventsErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/sitemaps/events/{subscriptionid}/*',
        ...options,
        ...params
    });
};

/**
 * Get sitemap events.
 */
export const getSitemapEvents1 = <ThrowOnError extends boolean = false>(parameters: {
    subscriptionid: string;
    sitemap?: string;
    pageid?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'path', key: 'subscriptionid' },
                { in: 'query', key: 'sitemap' },
                { in: 'query', key: 'pageid' }
            ] }]);
    return (options?.client ?? client).get<GetSitemapEvents1Responses, GetSitemapEvents1Errors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/sitemaps/events/{subscriptionid}',
        ...options,
        ...params
    });
};

/**
 * Get all available sitemaps.
 */
export const getSitemaps = <ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) => (options?.client ?? client).get<GetSitemapsResponses, unknown, ThrowOnError, 'data'>({
    responseStyle: 'data',
    url: '/sitemaps',
    ...options
});

/**
 * Initiates a new item state tracker connection
 */
export const initNewStateTacker = <ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) => (options?.client ?? client).get<InitNewStateTackerResponses, unknown, ThrowOnError, 'data'>({
    responseStyle: 'data',
    url: '/events/states',
    ...options
});

/**
 * Get all events.
 */
export const getEvents = <ThrowOnError extends boolean = false>(parameters?: {
    topics?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'query', key: 'topics' }] }]);
    return (options?.client ?? client).get<GetEventsResponses, GetEventsErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/events',
        ...options,
        ...params
    });
};

/**
 * Changes the list of items a SSE connection will receive state updates to.
 */
export const updateItemListForStateUpdates = <ThrowOnError extends boolean = false>(parameters: {
    connectionId: string;
    body?: Array<string>;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'connectionId' }, { in: 'body' }] }]);
    return (options?.client ?? client).post<UpdateItemListForStateUpdatesResponses, UpdateItemListForStateUpdatesErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/events/states/{connectionId}',
        ...options,
        ...params,
        headers: {
            'Content-Type': '*/*',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Get a single transformation
 */
export const deleteTransformation = <ThrowOnError extends boolean = false>(parameters: {
    uid: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'uid' }] }]);
    return (options?.client ?? client).delete<DeleteTransformationResponses, DeleteTransformationErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/transformations/{uid}',
        ...options,
        ...params
    });
};

/**
 * Get a single transformation
 */
export const getTransformation = <ThrowOnError extends boolean = false>(parameters: {
    uid: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'uid' }] }]);
    return (options?.client ?? client).get<GetTransformationResponses, GetTransformationErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/transformations/{uid}',
        ...options,
        ...params
    });
};

/**
 * Put a single transformation
 */
export const putTransformation = <ThrowOnError extends boolean = false>(parameters: {
    uid: string;
    transformation: Transformation;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'uid' }, { key: 'transformation', map: 'body' }] }]);
    return (options?.client ?? client).put<PutTransformationResponses, PutTransformationErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/transformations/{uid}',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Get all transformation services
 */
export const getTransformationServices = <ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) => (options?.client ?? client).get<GetTransformationServicesResponses, unknown, ThrowOnError, 'data'>({
    responseStyle: 'data',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/transformations/services',
    ...options
});

/**
 * Get a list of all transformations
 */
export const getTransformations = <ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) => (options?.client ?? client).get<GetTransformationsResponses, unknown, ThrowOnError, 'data'>({
    responseStyle: 'data',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/transformations',
    ...options
});

/**
 * Get all registered UI components in the specified namespace.
 */
export const getRegisteredUiComponentsInNamespace = <ThrowOnError extends boolean = false>(parameters: {
    namespace: string;
    summary?: boolean;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'namespace' }, { in: 'query', key: 'summary' }] }]);
    return (options?.client ?? client).get<GetRegisteredUiComponentsInNamespaceResponses, unknown, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/ui/components/{namespace}',
        ...options,
        ...params
    });
};

/**
 * Add a UI component in the specified namespace.
 */
export const addUiComponentToNamespace = <ThrowOnError extends boolean = false>(parameters: {
    namespace: string;
    rootUiComponent?: RootUiComponent;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'namespace' }, { key: 'rootUiComponent', map: 'body' }] }]);
    return (options?.client ?? client).post<AddUiComponentToNamespaceResponses, unknown, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/ui/components/{namespace}',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Remove a specific UI component in the specified namespace.
 */
export const removeUiComponentFromNamespace = <ThrowOnError extends boolean = false>(parameters: {
    namespace: string;
    componentUID: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'namespace' }, { in: 'path', key: 'componentUID' }] }]);
    return (options?.client ?? client).delete<RemoveUiComponentFromNamespaceResponses, RemoveUiComponentFromNamespaceErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/ui/components/{namespace}/{componentUID}',
        ...options,
        ...params
    });
};

/**
 * Get a specific UI component in the specified namespace.
 */
export const getUiComponentInNamespace = <ThrowOnError extends boolean = false>(parameters: {
    namespace: string;
    componentUID: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'namespace' }, { in: 'path', key: 'componentUID' }] }]);
    return (options?.client ?? client).get<GetUiComponentInNamespaceResponses, GetUiComponentInNamespaceErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/ui/components/{namespace}/{componentUID}',
        ...options,
        ...params
    });
};

/**
 * Update a specific UI component in the specified namespace.
 */
export const updateUiComponentInNamespace = <ThrowOnError extends boolean = false>(parameters: {
    namespace: string;
    componentUID: string;
    rootUiComponent?: RootUiComponent;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'path', key: 'namespace' },
                { in: 'path', key: 'componentUID' },
                { key: 'rootUiComponent', map: 'body' }
            ] }]);
    return (options?.client ?? client).put<UpdateUiComponentInNamespaceResponses, UpdateUiComponentInNamespaceErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/ui/components/{namespace}/{componentUID}',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Get all registered UI tiles.
 */
export const getUiTiles = <ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) => (options?.client ?? client).get<GetUiTilesResponses, unknown, ThrowOnError, 'data'>({
    responseStyle: 'data',
    url: '/ui/tiles',
    ...options
});

/**
 * Gets the default voice.
 */
export const getDefaultVoice = <ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) => (options?.client ?? client).get<GetDefaultVoiceResponses, GetDefaultVoiceErrors, ThrowOnError, 'data'>({
    responseStyle: 'data',
    url: '/voice/defaultvoice',
    ...options
});

/**
 * Gets a single interpreter.
 */
export const getVoiceInterpreterByUid = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    id: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }, { in: 'path', key: 'id' }] }]);
    return (options?.client ?? client).get<GetVoiceInterpreterByUidResponses, GetVoiceInterpreterByUidErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/voice/interpreters/{id}',
        ...options,
        ...params
    });
};

/**
 * Get the list of all interpreters.
 */
export const getVoiceInterpreters = <ThrowOnError extends boolean = false>(parameters?: {
    'Accept-Language'?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }] }]);
    return (options?.client ?? client).get<GetVoiceInterpretersResponses, unknown, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/voice/interpreters',
        ...options,
        ...params
    });
};

/**
 * Sends a text to the default human language interpreter.
 */
export const interpretTextByDefaultInterpreter = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    body: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }, { in: 'body' }] }]);
    return (options?.client ?? client).post<InterpretTextByDefaultInterpreterResponses, InterpretTextByDefaultInterpreterErrors, ThrowOnError, 'data'>({
        bodySerializer: null,
        responseStyle: 'data',
        url: '/voice/interpreters',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'text/plain',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Get the list of all voices.
 */
export const getVoices = <ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) => (options?.client ?? client).get<GetVoicesResponses, unknown, ThrowOnError, 'data'>({
    responseStyle: 'data',
    url: '/voice/voices',
    ...options
});

/**
 * Sends a text to a given human language interpreter(s).
 */
export const interpretText = <ThrowOnError extends boolean = false>(parameters: {
    'Accept-Language'?: string;
    ids: Array<string>;
    body: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'headers', key: 'Accept-Language' },
                { in: 'path', key: 'ids' },
                { in: 'body' }
            ] }]);
    return (options?.client ?? client).post<InterpretTextResponses, InterpretTextErrors, ThrowOnError, 'data'>({
        bodySerializer: null,
        responseStyle: 'data',
        url: '/voice/interpreters/{ids}',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'text/plain',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Executes a simple dialog sequence without keyword spotting for a given audio source.
 */
export const listenAndAnswer = <ThrowOnError extends boolean = false>(parameters?: {
    'Accept-Language'?: string;
    sourceId?: string;
    sttId?: string;
    ttsId?: string;
    voiceId?: string;
    hliIds?: Array<string>;
    sinkId?: string;
    listeningItem?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'headers', key: 'Accept-Language' },
                { in: 'query', key: 'sourceId' },
                { in: 'query', key: 'sttId' },
                { in: 'query', key: 'ttsId' },
                { in: 'query', key: 'voiceId' },
                { in: 'query', key: 'hliIds' },
                { in: 'query', key: 'sinkId' },
                { in: 'query', key: 'listeningItem' }
            ] }]);
    return (options?.client ?? client).post<ListenAndAnswerResponses, ListenAndAnswerErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/voice/listenandanswer',
        ...options,
        ...params
    });
};

/**
 * Speaks a given text with a given voice through the given audio sink.
 */
export const textToSpeech = <ThrowOnError extends boolean = false>(parameters: {
    voiceid?: string;
    sinkid?: string;
    volume?: string;
    body: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'query', key: 'voiceid' },
                { in: 'query', key: 'sinkid' },
                { in: 'query', key: 'volume' },
                { in: 'body' }
            ] }]);
    return (options?.client ?? client).post<TextToSpeechResponses, unknown, ThrowOnError, 'data'>({
        bodySerializer: null,
        responseStyle: 'data',
        url: '/voice/say',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'text/plain',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Start dialog processing for a given audio source.
 */
export const startDialog = <ThrowOnError extends boolean = false>(parameters?: {
    'Accept-Language'?: string;
    sourceId?: string;
    ksId?: string;
    sttId?: string;
    ttsId?: string;
    voiceId?: string;
    hliIds?: string;
    sinkId?: string;
    keyword?: string;
    listeningItem?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [
                { in: 'headers', key: 'Accept-Language' },
                { in: 'query', key: 'sourceId' },
                { in: 'query', key: 'ksId' },
                { in: 'query', key: 'sttId' },
                { in: 'query', key: 'ttsId' },
                { in: 'query', key: 'voiceId' },
                { in: 'query', key: 'hliIds' },
                { in: 'query', key: 'sinkId' },
                { in: 'query', key: 'keyword' },
                { in: 'query', key: 'listeningItem' }
            ] }]);
    return (options?.client ?? client).post<StartDialogResponses, StartDialogErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/voice/dialog/start',
        ...options,
        ...params
    });
};

/**
 * Stop dialog processing for a given audio source.
 */
export const stopDialog = <ThrowOnError extends boolean = false>(parameters?: {
    sourceId?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'query', key: 'sourceId' }] }]);
    return (options?.client ?? client).post<StopDialogResponses, StopDialogErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/voice/dialog/stop',
        ...options,
        ...params
    });
};

/**
 * Remove a single logger.
 */
export const removeLogger = <ThrowOnError extends boolean = false>(parameters: {
    loggerName: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'loggerName' }] }]);
    return (options?.client ?? client).delete<RemoveLoggerResponses, unknown, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/logging/{loggerName}',
        ...options,
        ...params
    });
};

/**
 * Get a single logger.
 */
export const getLogger = <ThrowOnError extends boolean = false>(parameters: {
    loggerName: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'loggerName' }] }]);
    return (options?.client ?? client).get<GetLoggerResponses, unknown, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/logging/{loggerName}',
        ...options,
        ...params
    });
};

/**
 * Modify or add logger
 */
export const putLogger = <ThrowOnError extends boolean = false>(parameters: {
    loggerName: string;
    loggerInfo: LoggerInfo;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'path', key: 'loggerName' }, { key: 'loggerInfo', map: 'body' }] }]);
    return (options?.client ?? client).put<PutLoggerResponses, PutLoggerErrors, ThrowOnError, 'data'>({
        responseStyle: 'data',
        security: [{ scheme: 'bearer', type: 'http' }],
        url: '/logging/{loggerName}',
        ...options,
        ...params,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers,
            ...params.headers
        }
    });
};

/**
 * Get all loggers
 */
export const getLogger1 = <ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) => (options?.client ?? client).get<GetLogger1Responses, unknown, ThrowOnError, 'data'>({
    responseStyle: 'data',
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/logging',
    ...options
});

/**
 * Gets all icon sets.
 */
export const getIconSets = <ThrowOnError extends boolean = false>(parameters?: {
    'Accept-Language'?: string;
}, options?: Options<never, ThrowOnError>) => {
    const params = buildClientParams([parameters], [{ args: [{ in: 'headers', key: 'Accept-Language' }] }]);
    return (options?.client ?? client).get<GetIconSetsResponses, unknown, ThrowOnError, 'data'>({
        responseStyle: 'data',
        url: '/iconsets',
        ...options,
        ...params
    });
};
